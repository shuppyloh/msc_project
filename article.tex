%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.4 (15/5/16)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com) with extensive modifications by
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------
\documentclass[a4paper,11pt, twoside,twocolumn]{article}
\usepackage{blindtext} % Package to generate dummy text throughout this template 

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[english]{babel} % Language hyphenation and typographical rules
\usepackage{multirow}
\usepackage{multicol}
\usepackage[left=2.5cm,right=2cm,top=2cm,bottom=2cm, hmarginratio=1:1,headheight=14pt,columnsep=15pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{graphicx}
\usepackage{enumitem} % Customized lists

\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small} % Set the abstract itself to small italic text

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
%\fancyhead[C]{Running title $\bullet$ May 2016 $\bullet$ Vol. XXI, No. 1} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section
\usepackage{titlesec}
\titleformat{name=\section}{\flushleft\bf\scshape\Large}{\thesection}{.5em}{}
\titleformat{name=\subsection}{\flushleft\bf\scshape\large}{\thesubsection}{.5em}{}
\titleformat{name=\subsubsection}{\flushleft\bf\scshape\normalsize}{\thesubsubsection}{.5em}{}

\usepackage{hyperref} % For hyperlinks in the PDF
\usepackage{amsfonts} % For more logic symbols
\usepackage{amssymb} % For more logic symbols
\usepackage[fleqn]{amsmath} % left aligned math
\usepackage{centernot} % to use not implies
\usepackage{array}
\usepackage{upgreek}
\setlength\parindent{0pt}

%----------------------------------------------------------------------------------------
%	Custom Logic Environment and  Bindings
%----------------------------------------------------------------------------------------
%eq numbering
\makeatletter
\newcommand{\eqnum}[1][]{\leavevmode\hfill\refstepcounter{equation}\label{#1}\textup{\tagform@{\theequation}}}
\makeatother
%environment formating
\newenvironment{logic}[1][null]
{\begin{flushleft} \small \label{#1}}
{\end{flushleft}}
%logic shortcuts
\newcommand*\rot{\rotatebox{90}}
\newcommand{\loin}{$\in$}
\newcommand{\loforall}{$\forall$}
\newcommand{\loexists}{$\exists$}
\newcommand{\loand}{$\land$}
\newcommand{\loor} {$\lor$}
\newcommand{\loneq} {$\neq$}
\newcommand{\losimeq} {$\simeq$}
\newcommand{\losubseteq}{$\subseteq$}
\newcommand{\loimplies}{$\implies$}
\newcommand{\lonimplies}{$\centernot\implies$}
\newcommand{\loimpliedby}{$\Longleftarrow$}
\newcommand{\lonimpliedby}{$\centernot\Longleftarrow$}
\newcommand{\losigma}{$\upsigma$}
\newcommand{\loturns} {$\vDash$}
\newcommand{\lochi}{$\upchi$}
\newcommand{\lophi}{$\upvarphi$}
\newcommand{\lorarrow}{$\rightarrow$}
\newcommand{\lonturns} {$\nvDash$}
\newcommand{\loiff} {$\iff$}
\newcommand{\loleadsto} {$\leadsto$}
\newcommand{\lomapsto} {$\mapsto$}
\newcommand{\locup} {$\cup$}
\newcommand{\lobigcup} {$\bigcup$}
\newcommand{\lotimes} {$\times$}
\newcommand{\loneg}{$\neg$}
\newcommand{\loexec}[2] {$\lfloor$#1$\rfloor _{\text{#2}}$}
\newcommand{\loconj}[1] {$\bar{\text{#1}}$}
\newcommand{\ablock} {\null\qquad}

%-----------------------
%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------
\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
\posttitle{\end{center}} % Article title closing formatting
\title{Object Capability Patterns:\\Policies and Specifications} % Article title
\author{%
\textsc{Shu-Peng Loh} \\[1ex] % Your name
\normalsize Imperial College London \\ % Your institution
\normalsize \href{mailto:shu.loh16@imperial.ac.uk}{shu.loh16@imperial.ac.uk} % Your email address
\and % if 2 authors are required, duplicate these 4 lines if more
\textsc{Sophia Drossopoulou}\\[1ex] % Second author's name
\normalsize Imperial College London \\ % Second author's institution
\normalsize \href{mailto:s.drossopoulou@imperial.ac.uk}{s.drossopoulou@imperial.ac.uk} % Second author's email address
}
\date{} % Leave empty to omit a date


\renewcommand{\maketitlehookd}{%
\begin{abstract}
\noindent  We propose a set of higher-order predicate logic to formally specify object-to-object interactions which can then be used to describe reference dynamics in an object-oriented computational model. Using these predicates, we attempt to formally specify the policies of well-established Object-Capability (OCap) patterns within the OCap literature which we have implemented in the capability-safe language Pony. We also offer some preliminary insights on how such specifications can be used in the context of a non-Ocap model by describing the security properties of a pattern built on the Ethereum smart contract programming language Solidity, which we argue implements a form of stack-based access control.\end{abstract}
}
\begin{document}
\renewcommand{\ref}[1]{\textit{\autoref{#1}}}
% Print the title
\maketitle

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{Introduction}
Recent widespread adoption of distributed ledger technology (blockchain) has created multiple decentralized, distributed computational platforms where millions of dollars are transacted over codified constructs called smart contracts\footnote{For example, as of 10 Aug 2017, Ethereum is a US\$28 billion blockchain platform with an in-built Turing-complete programming language that can be used to create and deploy such contracts.}.
The power of distributed modern computing hence lies in facilitating cooperation between multiple agents, but it comes with risk as an agent is vulnerable to \textit{unexpected} outcomes\footnote{Representing in general any outcome arising from a piece of code execution that has deviated from an agent's original intention or objective independent from code.} from participating in these smart contracts. This might generally arise from two issues: 
\begin{itemize}
\item oversight or misconception of the outcomes of executing a piece of \textit{known} code
\item failure to defend against malicious execution of \textit{unknown} code components\end{itemize}
\noindent These two issue are often closely intertwined in any system of execution that has both trusted and untrusted code components (the second issue is often a result of the first).

In recent years the Object-Capability (OCap) model has received increasing attention as a compelling approach to building robust, distributed systems that promote what Miller\cite{miller2006} calls \textit{cooperation without vulnerability}. The OCap model attemps to address these two issues by alleviating security as a separate concern from the mind of the programmer, by leveraging the object-oriented programming paradigm and imposing certain prohibitions.
%----------------------------------------------------------------------------------------
%   OCap Model
%----------------------------------------------------------------------------------------
\section{OCap Model}
The OCap model uses the reference graph of the objects as the access graph, and strictly requires objects to interact with each other only by sending messages on object references\cite{miller2003b}.
\subsection{From Capability to Object-Capability}
\subsection{OCap Languages}
\begin{itemize}
\item Joe-E (inspired by Java)
\item Emily (inspired by OCaml)
\item Caja (inspired by JavaScript)
\item E
\item Pony
\end{itemize}
\subsubsection{Language Restrictions}
\subsection{OCap Patterns}
An OCap pattern is a concrete representation of the OCap model and comprises a set of objects connected to each other by capabilities. Objects interact with each other by sending messages on capabilities. An OCap pattern may be visualised as a directed graph---nodes represent objects, and each edge from an object \textit{o} to another \textit{o'} represents \textit{o} holding a capability that allows it to directly access \textit{o'}.
%----------------------------------------------------------------------------------------
%   Formal Specifications
%----------------------------------------------------------------------------------------
\section{Formal specifications}
\subsection{Definitions}\noindent
We borrow liberally the definitions of runtime state, module and arising configurations from the appendix of \cite{drossopoulou2015b}.\\
\textbf{Runtime state:}
 \losigma\ consists of a stack frame \lophi, and a heap \lochi. A stack frame is a mapping from receiver (this) to its address, and from the local variables (VarId) and parameters (ParId) to their values. Values are integers, the booleans true or false, addresses, or null. The heap maps addresses to objects. Objects are tuples consisting of the class of the object, and a mapping from field identifiers onto values.
\begin{logic}[Runtime state]
\losigma\ \loin\ state = frame \lotimes\ heap \\
\lophi \loin\ frame = StackId $\rightarrow$ val \\
\lochi \loin\ heap = addr $\rightarrow$ object \\
v \loin\ val = \{\texttt{null}, \texttt{true}, \texttt{false}\} \locup\ \textit{addr} \locup\ $\mathbb{N}$ \\
StackId = \{\textit{this}\} \locup\ VarId \locup\ ParId \\
object = ClassId \lotimes (FieldId $\rightarrow$ val)
\end{logic}
\textbf{Module:}
\begin{logic}[Module]
M \loin\ Module = ClassId \locup\ SpecId\linebreak\ablock\qquad\qquad\quad $\rightarrow$ \linebreak
\ablock \qquad \qquad \quad (ClassDescr \locup\ Specification)
\end{logic}

\textbf{Reach and Execution:}\\
\begin{logic}[Reach and Execution]\end{logic}



\textbf{Arising Configurations}\\
\begin{logic}[Arising]\end{logic}



\textbf{Domination:}\\
\begin{logic}[Domination]\end{logic}



\subsubsection{MayAccess Definitions}
We define in total four flavours of MayAccess predicates that describe the relation between two entities in a system (of arity 2 that represent the identifiers of these entities). These four flavours represent a combination of space (distance) and time (state):
\begin{itemize}
\item distance: directly ($Dir$) or indirectly ($Ind$)
\item state: now ($Now$) or eventually ($Eve$)
\end{itemize}
and are broad enough to describe both non-OCap and OCap models:
\begin{logic}[MayAccessDirNow]
M,\losigma\ \loturns\ MayAccess$^{Dir,Now}$(x,e) \loiff \linebreak
\ablock \loexists f. \loexec{x.f}{\losigma} = \loexec{e}{\losigma}
\loor \linebreak
\ablock (\losigma(this) = \loexec{x}{\losigma} \loand\ \loexists y. \losigma(y) = \loexec{e}{\losigma})
\end{logic}
\begin{logic}[MayAccessDirEve]
 M,\losigma\ \loturns\ MayAccess$^{Dir,Eve}$(x,e) \loiff \linebreak
\ablock \loexists \losigma' \loin Arising(M,\losigma).\linebreak
\ablock M,\losigma'\ \loturns\ MayAccess$^{Dir,Now}$(x,e) 
\end{logic}
\begin{logic}[MayAccessIndNow]
M,\losigma\ \loturns\ MayAccess$^{Ind,Now}$(x,e) \loiff \linebreak
\ablock \loexists \loconj{f}. \loexec{x.\loconj{f}}{\losigma} = \loexec{e}{\losigma}
\loor \linebreak
\ablock (\losigma(this) = \loexec{x}{\losigma} \loand\ \loexists y. \losigma(y.\loconj{f}) = \loexec{e}{\losigma})
\end{logic}
\begin{logic}[MayAccessIndEve]
M,\losigma\ \loturns\ MayAccess$^{Ind,Eve}$(x,e) \loiff \linebreak
\ablock \loexists \losigma' \loin Arising(M,\losigma).\linebreak
\ablock M,\losigma'\ \loturns\ MayAccess$^{Ind,Now}$(x,e) 
\end{logic}

A note on \textit{f} and \textit{\loconj{f}}\ : While f can considered as a field, it can also represent a method that returns a val.
Similarly \loconj{f} can be considered a series of fields, or methods that return a val, or a combination of both.\\

We surmarise the relationships between the four flavours of MayAccess in \ref{MayAccessTable}:
\begin{table}[hbtp]
\small
\caption{MayAccess$^{*,*}$(x,e) Relations}
\centering
\begin{tabular*}{\linewidth}{c|ccc}\toprule
& \bf Now & & \bf Eventually\\
\hline
\multirow{5}{*}{\rot{\bf Indirect \enspace Direct \:}} & \multirow{2}{*}{MayAccess$^{Dir,Now}$} & \loimplies & \multirow{2}{*}{MayAccess$^{Dir, Eve}$} \\
& & \lonimpliedby &  \\
& \rot{\loimpliedby} \rot{\lonimplies}& &\rot{\loimpliedby} \rot{\lonimplies} \\
& \multirow{2}{*}{MayAccess$^{Ind,Now}$} & \loimplies & \multirow{2}{*}{MayAccess$^{Ind, Eve}$} \\
& & \lonimpliedby &\\
\label{MayAccessTable}
\end{tabular*}
\end{table}

Let us assume that both x and e are well-defined. Note that without imposing any further assumptions (such as those from the OCap model), we have defined \textit{both} MayAccess$^{Dir,Now}$(x,e) and MayAccess$^{Ind,Now}$(x,e) to mean forms of very weak access---that a directed path exists from x to e, but we do \textit{not} imply that such a path is traverseable by x (it might or might not be traverseable). Indeed, these definitions by themselves represent mere \textit{possibilities} of interaction (or possible authorities), they do \textit{not} represent that interaction (or authority) would succeed. The difference between MayAccess$^{Dir,Now}$(x,e) and MayAccess$^{Ind,Now}$(x,e) is only the computational distance between x and e on the reference graph, where the latter involves possibly intermediate entities (or objects in an object-oriented model).\\

What do the definitions mean then for non-OCap and OCap models in an object-oriented world? Again, let us assume both o and o' are well-defined, valid object references. In non-OCap models, the possible presence of a global ambient authority means the predicates above say \textit{nothing} about whether any interaction between an object o and o' would succeed. This is true even if o possesses directly the reference of o', where MayAccess$^{Dir,Now}$(o,o') holds. For all we know, we could easily have in a non-OCap language a feature to completely restrict access to o' using a global ambient authority, such that any object in the programming world which possesses references of o' cannot use them, and all paths leading to o' represent merely possibilities of interaction, but from which no authority can possibly arise.\\

Could we say more about OCap systems? In OCap systems, there can be no global ambient authority so that an object reference by itself represents both the designation and the authority to use the object. This therefore leads us to be able to make a crucial distinction between MayAccess$^{Ind,Now}$(o,o') and MayAccess$^{Dir,Now}$(o,o') in the OCap model:
\begin{itemize}
\item MayAccess$^{Ind,Now}$(o,o') means---\textit{only}\\
\ablock 1. a directed path from o to o' exists\\
\ablock\ablock (possible authority)
\item MayAccess$^{Dir,Now}$(o,o') means---\textit{both}\\
\ablock 1. a directed path from o to o' exists\\
\ablock\ablock (possible authority) \textit{and}\\
\ablock 2. o's authority to use o' \textit{will} succeed
\end{itemize}
We elaborate the distinction with the following OCap example where there is a particular state \losigma\ of the system where, o$_1$.next points to o$_2$, and o$_2$.next points to o$_3$. o$_2$.next is a private method that can only be called internally by o$_2$. In this example, M,\losigma ~\loturns ~MayAccess$^{Ind,Now}$(o$_1$,o$_3$) holds, regardless of whether o$_2$.next is traverseable by o$_1$. We say here that a path from o$_1$ to o$_3$ exists, but is not traverseable by o$_1$. On the other hand, MayAccess$^{Dir,Now}$(o$_1$,o$_3$) does not hold true, because o$_3$ is not reachable from $o_1$ in a single step---o$_2$ sits between them on the reference graph as an intermediate object, and can possibly prevent or allow traversal from o$_1$ to o$_3$ (in this example, o$_2$ prevents such a traversal).\\

What does it mean then for MayAccess$^{Dir,Now}$(*,*) to hold in an OCap model? From the same example, MayAccess$^{Dir,Now}$(o$_1$,o$_2$) holds and implies a stronger form of access---it means that a path exists from o$_1$ to o$_2$, and that such a path \textit{is} traverseable. This is because, by the definition of the predicate and configuration of the example, the object reference of o$_2$ exists within o$_1$'s state. Therefore, o$_2$ is guaranteed therefore to be accessible, and its authority exercisable, by o$_1$, without the interference of any ambient authority. Notice how this o$_1$-o$_2$ relationship differs from the o$_1$-o$_3$ relationship, where o$_1$ cannot guarantee that it can exercise the authority of o$_2$.next which points to o$_3$, since o$_2$.next does not exist within o$_1$'s state---it is possible that o$_2$.next is protected by x$_2$ through encapsulation and data-hiding.\\
Within an OCap model, we can now be convinced that the stronger
\begin{logic}
MayAccess$^{Dir,Now}$(o$_1$,o$_2$) \losimeq \linebreak
\ablock o$_1$ has the capability of o$_2$\end{logic}
while the weaker MayAccess$^{Ind,Now}$(o$_1$,o$_3$) does not say anything about whether o$_1$ has the capability of o$_3$, but that only a directed path exists. It does however, represent a necessary condition for capability.
\begin{logic}
MayAccess$^{Ind,Now}$(o$_1$,o$_3$) \losimeq\ \linebreak
\ablock there is a directed path from o$_1$ to o$_2$\linebreak
\\
o$_1$ has the capability of o$_3$ \loimplies \linebreak
\ablock MayAccess$^{Ind,Now}$(o$_1$,o$_3$)\end{logic}
\subsubsection{MayAffect Definitions}
With our access predicates in place, we introduce a set of predicates that describe changes to the state of a system. Again, we highlight that these predicates are broad enough to describe both non-OCap and OCap models. 
\begin{logic}
M,\losigma\ \loturns\ MayAffect$^{Now}$(x,e) \loiff \linebreak
\ablock \loexists \loconj{m},\loconj{a},\losigma'. x.\loconj{m}(\loconj{a}) \loleadsto\ \losigma' \loand \loexec{e}{\losigma} \loneq \loexec{e}{\losigma'}
\linebreak \\
M,\losigma\ \loturns\ MayAffect$^{Eve}$(x,e) \loiff \linebreak
\ablock \loexists \losigma \loin Arising(M,\losigma).\linebreak
\ablock \loexists \loconj{m},\loconj{a},\losigma'. x.\loconj{m}(\loconj{a}) \loleadsto\ \losigma' \loand \loexec{e}{\losigma} \loneq \loexec{e}{\losigma'}
\linebreak \\
\textit{If e is an object:} \\
\loforall e\loin Object. \loexec{e}{\losigma} \loneq \loexec{e}{\losigma'} \loiff \linebreak
\ablock \loexists f. \loexec{e.f}{\losigma} \loneq \loexec{e.f}{\losigma'}
\end{logic}

\begin{table}[hbtp]
\caption{MayAffect(o,o') Relations in OCap}
\centering
\begin{tabular*}{\linewidth}{ccc}\toprule
\multirow{2}{*}{MayAffect$^{Now}$} & \loimplies & \multirow{2}{*}{MayAffect$^{Eve}$} \\
& \lonimpliedby &  \\
\bottomrule
\end{tabular*}
\end{table}

\subsection{OCap Security Implications}


\subsubsection{What is protection?}
In an object-oriented world\footnote{
To simplify our discussion, we work with the variables \{o,o'\}\loin Object for this entire section.}
, security concerns between objects are often a question of whether what one object can do to another object in \textit{any} eventual state of a system. Because an object encapsulates both internal state and behaviour, strictly speaking, security of an object should govern over both the integrity of the object's fields (internal state) and whether the objects' methods can be called (behaviour). Our predicates are broad enough to enable a discussion of both protection of state (MayAffect$^{Eve}$) and behaviour (MayAccess$^{Dir,Eve}$)\footnote{ Our MayAccess$^{Dir,Eve}$ is not weak enough to reason specifically which behaviours can be called. This is however not a big issue in \textit{pure} OCap systems, where often giving away the capability of an object typically means allowing \textit{all} public behaviours of the object to be called without distinction.}. We emphasize however that protecting either state or behaviour of an object, does \textit{not} necessarily imply the other. In fact, a common feature in OCap patterns is being able to protect a sensitive object's behaviours (they cannot be called directly by untrusted objects), but at the some allowing the same untrusted objects to modify the object's state in some controlled way.\\

There are however, some flexibility in working with objects, that allows us to simplify our discussion and work with only a broad definition of state protection in terms of our MayAffect$^{Eve}$ predicate, \textit{without} thinking too much about specific fields of the object we want to protect or the protection of behaviour. Moving away from our broad definition of whether an object may be affected (we defined it as being able to change at least one field of the object), to more precise spcifications of which particular field(s) of the object may be affected, should be trivial. We can in theory also stay and reason within our framework by separating the particular concerned field(s) of the object into separately encapsulated objects. We merely have to be careful as to \textit{which} object's state we want to protect. Furthermore, in theory one can easily introduce a field within an object that behaves like a 'signal' which would be modified whenever a specified behaviour is called. Preventing a particular behaviour to be called by an untrusted object then becomes equivalent to denying the untrusted object the ability to modify the particular state of the signal field of the object.\\

With these simplifications, protection for us then becomes solely a matter of whether we can allow or deny an object to modify the state of another. In the subsections below we build the neccessary conditions for MayAffect$^{Eve}$, where MayAffect$^{Eve}$ is placed in the antecedent, and we examine which of the family of MayAccess predicates is placed in the consequent. To help us achieve this, we also formalize our assumptions and the rules of OCap, using our predicates, to help guide us in constructing our necessary conditions.\\

In building our necessary conditions for state protection in the next subsection notice how we have focused on finding the necessary conditions for the weaker predicate MayAffect$^{Eve}$ rather than MayAffect$^{Now}$ in the antecedent. This is because negation on both sides of the implication, would yield a stronger \loneg MayAffect$^{Eve}$ in the consequent. In practical terms, if we are concerned with the protection of o' from o, it is also often not very useful to have a policy where \loneg MayAffect$^{Now}$(o,o') holds but \loneg MayAffect$^{Eve}$(o,o') does not. Furthermore, by ensuring \loneg MayAffect$^{Eve}$(o,o') holds, we can also ensure \loneg MayAffect$^{Now}$(o,o') holds since by contraposition:

\begin{logic}
$[$MayAffect$^{Now}$(o,o') \loimplies MayAffect$^{Eve}$(o,o')$]$\linebreak
\ablock \loimplies\linebreak
$[$\loneg MayAffect$^{Eve}$(o,o') \loimplies \loneg MayAffect$^{Now}$(o,o')$]$\\
\end{logic}

In building the necessary conditions for the predicate MayAffect$^{Eve}$, we are also more concerned with finding the configuration of MayAccess$^{*,Now}$, rather than MayAccess$^{*,Eve}$. This is because it is easier to implement or prove a configuration of relations that holds in \textit{one} specific state and hence much more useful in practice, than think about whether a configuration holds in \textit{all} possible eventual states.\\
\subsection{Formal Implications}
\subsubsection{Formalizing OCap rules}
We begin our reasoning of protection in our OCap model, by introducing the assumption that all fields in our objects can only be declared private. Consequently, this implies the necessary condition that an object's state can only be modified if one of it's behaviour is called, and therefore require at least one other object in the system that holds its capability. We do not think this is restrictive in any case, the programmer merely has to write explicitly a method to return an object's field.

\begin{logic}
\hrule\null
\textsc{\normalsize *Private Fields Assumption (PFA)}\\
M,\losigma\ \loturns\ \loexists X*\loin Obj. MayAffect$^{Now}$(X*,o') \loimplies \linebreak
	\ablock \ablock \loexists Y*\loin Obj. MayAccess$^{Dir,Now}$(Y*,o')
\linebreak \\
\textit{By contraposition,}\linebreak
M,\losigma\ \loturns\ 	\loforall Y*\loin Obj. \loneg MayAccess$^{Dir,Now}$(Y*,o') \loimplies \linebreak
	\ablock \ablock \loforall X*\loin Obj. \loneg MayAffect$^{Now}$(X*,o')
\linebreak
\hrule
\end{logic}

This means that in order for an object X*'s state to change, it must be done through some object Y* calling its behaviour (Y* can refer to the same object as X*). Equivalently, denying all objects in the system the ability to call an object's behaviour implies that no object can modify the object's state.\\


\textbf{Rule 1: Objects can only interact with each other through sending messages on capabilities.}
Therefore, if an object o can affect o', then there must be a path from o to o':
\begin{logic}[Implication 1]
\hrule\null
\textsc{\normalsize *Necessary Path Condition 1 (NPC1)}\\
M,\losigma\ \loturns\ MayAffect$^{Eve}$(o,o') \loimplies\linebreak
	\ablock MayAccess$^{Ind,Eve}$(o,o')
\linebreak \\
\textit{By contraposition,}\linebreak
M,\losigma\ \loturns\ \loneg MayAccess$^{Ind,Eve}$(o,o') \loimplies\linebreak
	\ablock \loneg MayAffect$^{Eve}$(o,o')
\linebreak
\hrule
\end{logic}
Here, we immediately see a first defensive outcome of the OCap model. Having no paths from object o to o' guarantees that the state of object o' cannot be modified by object o.\\

\textbf{Rule 2: Objects cannot forge capabilities, and only connectivity begets connectivity.}

\begin{logic}
\hrule\null
\textsc{\normalsize *Global Path Connectivity (GPC)}\
$[$\loexists Y*\loin{Object}. MayAccess$^{Ind,Now}$(Y*,o')$]$ \loiff\linebreak
\ablock $[$\loexists X*\loin{Object}. MayAccess$^{Dir,Now}$(X*,o')$]$
\linebreak\\
\textit{By contraposition,}\linebreak
$[$\loforall X*\loin{Object}. \loneg MayAccess$^{Dir,Now}$(X*,o')$]$ \loiff\linebreak
\ablock $[$\loforall Y*\loin{Object}. \loneg MayAccess$^{Ind,Now}$(Y*,o')$]$\linebreak
\hrule
\end{logic}
In addition to path being a necessary condition for capability, \textsc{gpc} gives us an additional new relation between the two concepts over the entire system, and says that in a given system of objects, $iff$ there exists an object Y* which has a path to o', then there exists an object X* that has the capability of o'. Looking from the left to right direction, this is directly derived from Rule 2, since the path from Y* to o' must either be a direct path (Y*==X*) or if not at the very least an object X* must have a direct path to o', in order for the path from Y* to o' to be well-established, where X* is the last object in the path before o'. Moving from the right to left direction, \textsc{gpc} says that if an object X* has a capability then there exist an object Y* with a path to o'. We can make this assertion because we know by definition that it holds when Y* refers to the same object as X*.\\

We now look for a relation between a path configuration at a state \losigma\ ($Now$) and eventual path configurations arising from \losigma\ ($Eve$).

\begin{logic}
\hrule\null
\textsc{\normalsize *Eventual Path Connectivity (EPC)}\\
M,\losigma\ \loturns\ 
MayAccess$^{Ind,Eve}$(o,o')\linebreak
\ablock \loimplies\linebreak
\ablock MayAccess$^{Ind,Now}$(o,o')\linebreak
\ablock \loor\linebreak
\ablock $\{$\loexists X*\loin Obj.$[($MayAccess$^{Ind,Now}$(o,X*) \loor \linebreak
\ablock \ablock \ablock \ablock MayAccess$^{Ind,Now}$(X*,o)$)$\linebreak
\ablock \ablock \ablock \ablock \loand \linebreak
\ablock \ablock \ablock \ablock MayAccess$^{Ind,Eve}$(X*,o')$]\}$
\linebreak \\
\textit{By contraposition,}\linebreak
M,\losigma\ \loturns\ 
\loneg MayAccess$^{Ind,Now}$(o,o')\linebreak
\ablock \loand\linebreak
\ablock \loforall X*\loin Obj.\loneg$[($MayAccess$^{Ind,Now}$(o,X*) \loor \linebreak
\ablock \ablock \ablock \ablock MayAccess$^{Ind,Now}$(X*,o)$)$\linebreak
\ablock \ablock \ablock \ablock \loand \linebreak
\ablock \ablock \ablock \ablock MayAccess$^{Ind,Eve}$(X*,o')$]$\linebreak
\ablock \loimplies\linebreak
MayAccess$^{Ind,Eve}$(o,o')\
\linebreak
\hrule
\end{logic}
The contraposition result of \textsc{epc} says that o' is eventually path-isolated from o in all possible states arising from \losigma\ when o is does not have a path to o' in \losigma\ \textit{and} for all object X* that has eventual paths to o, it is not true in \losigma\ that either o is connected to X* or X* is connected to o by some path.\\

Using \textsc{npc1} and \textsc{epc}, we derive \textsc{npc2} below which is a relation between state protection in eventual outcomes, and present path configurations. \textsc{epc} says that to protect o' from o in all states arising from a state \losigma, we only need to ensure isolation of o' in \losigma, provided o' exists in \losigma :

\begin{logic}
\hrule\null
\textsc{\normalsize *Necessary Path Condition 2 (NPC2)}\\
M,\losigma\ \loturns\ MayAffect$^{Eve}$(o,o')\linebreak
\ablock \loimplies\linebreak
\ablock MayAccess$^{Ind,Now}$(o,o')\linebreak
\ablock \loor\linebreak
\ablock $\{$\loexists X*\loin Obj.$[($MayAccess$^{Ind,Now}$(o,X*) \loor \linebreak
\ablock \ablock \ablock \ablock MayAccess$^{Ind,Now}$(X*,o)$)$\linebreak
\ablock \ablock \ablock \ablock \loand \linebreak
\ablock \ablock \ablock \ablock MayAccess$^{Ind,Eve}$(X*,o')$]\}$
\linebreak \\
\textit{By contraposition,}\linebreak
M,\losigma\ \loturns\ 
\loneg MayAccess$^{Ind,Now}$(o,o')\linebreak
\ablock \loand\linebreak
\ablock \loforall X*\loin Obj.\loneg$[($MayAccess$^{Ind,Now}$(o,X*) \loor \linebreak
\ablock \ablock \ablock \ablock MayAccess$^{Ind,Now}$(X*,o)$)$\linebreak
\ablock \ablock \ablock \ablock \loand \linebreak
\ablock \ablock \ablock \ablock MayAccess$^{Ind,Eve}$(X*,o')$]$\linebreak
\ablock \loimplies\linebreak
	\ablock\loneg MayAffect$^{Eve}(o,o')$\linebreak
\hrule
\end{logic}
The interpretation of \textsc{npc2} is identical to \textsc{epc}, with protection of state being made an explicit consequent from the conditions of \textsc{epc}.
So far these results serve as a good base to enforce \loneg MayAffect$^{Eve}(o,o')$ but we require \textit{stronger} necessary conditions for \loneg MayAffect$^{Eve}(o,o')$, because enforcing protection of an object's state with just these conditions require the impractical configuration that o is path-isolated from o' on the reference graph (no paths). Cooperation between objects imply that there needs to be some path established between the objects for interaction to take place. Therefore, we can expect neither \loneg MayAccess$^{Ind,Now}$(o,o') nor \loneg MayAccess$^{Ind,Eve}$(o,o') to hold in a system that allows cooperation between o and o'.\\


So far we have only defined the relation between the existence of paths and an object's state. This is not the full picture, as we have not said anything about capabilities, or whether the paths are traverseable. We now examine whether it is possible to build a relation from MayAffect$^{Eve}$ to MayAccess$^{Dir,Eve}$.
\begin{logic}
\hrule\null
\textsc{\normalsize *Necessary Execution Condition 1 (NEC1)}\\
M,\losigma\ \loturns\ MayAffect$^{Eve}$(o,o') \loimplies\linebreak
	\ablock \loexists X*\loin{Object}. MayAccess$^{Dir,Eve}$(X*,o') 
\linebreak\\
\textit{By contraposition and quantifier equivalence,}\linebreak
M,\losigma\ \loturns\ $[$\loforall X*\loin{Object}. \loneg MayAccess$^{Dir,Eve}$(X*,o')$]$\loimplies\linebreak
	\ablock \loneg MayAffect$^{Eve}$(o,o') \linebreak
\hrule
\end{logic}
\textsc{nec1} is a stronger version of \textsc{npc1} and says that in order for an object o to modify the state of o', there must exist an object X* that has a direct path to o', and that X* \textit{can} traverse such a path. This is derived trivially from our \textsc{pfa} assumption in the beginning. Consequently, in our contraposition result, we can deny \textit{all} objects in our system capability of o' to enforce the protection of o' from o. \textsc{nec1} does not yield a very useful result, as this is just another way of implementing protection of o' from o through denying all paths to o' in the system reference graph. To see why denying all objects the capability of o' is equivalent to denying all paths to o', see the results from \textsc{gpc}.\\

In \textsc{nec1}, if X* refers to the same object as o, then we have a straightforward configuration where object o has the capability of o' and can therefore affect o'. However, very crucially, o having the capability of o' is \textit{not} a sufficient condition---denying o the capability of o' does \textit{not} deny o the ability to affect o', since X* can refer to an object that is \textit{not} o. \textsc{nec2} below is an expansion of \textsc{nec1} to illustrate this crucial result in the OCap model.
\begin{logic}
\hrule\null
\textsc{\normalsize *Necessary Execution Condition 2 (NEC2)}\\
M,\losigma\ \loturns\ MayAffect$^{Eve}$(o,o') \loimplies\linebreak
	\ablock $[$MayAccess$^{Dir,Eve}$(o,o') \loor\linebreak
	\ablock \loexists X*\loin{Object}, X*\loneq o. MayAccess$^{Dir,Eve}$(X*,o')$]$
\linebreak\\
\textit{By contraposition,}\linebreak
M,\losigma\ \loturns\ $[$\loneg MayAccess$^{Dir,Eve}$(o,o') \loand\linebreak
	\ablock \loforall X*\loin{Object}, X*\loneq o. \loneg MayAccess$^{Dir,Eve}$(X*,o')$]$ \linebreak
	\ablock \loimplies\loneg MayAffect$^{Eve}$(o,o')\linebreak
\hrule
\end{logic}
We now examine the second half of the necessary condition in \textsc{nec2}:\\
$[$\loexists X*\loin{Object}, X*\loneq o. MayAccess$^{Dir,Eve}$(X*,o')$]$
\\ which means that there exists object X* that is \textit{not} object o, that must have the capability of o'.
We now make use of our result in \textsc{npc1}, which states that a path must exist from o to o' in order for MayAffect$^{Eve}$(o,o') to hold. Since X* is not o, and X* has a direct path to o', we have to connect o to X* in order to connect o to o'. With this, we can now construct \textsc{nec3} from \textsc{nec2} and \textsc{npc1}.


\begin{logic}
\hrule\null
\textsc{\normalsize *Necessary Execution Condition 3 (NEC3)}\\
M,\losigma\ \loturns\ MayAffect$^{Eve}$(o,o') \loimplies\linebreak
	\ablock MayAccess$^{Dir,Eve}$(o,o') \loor \linebreak
	\ablock $[$\loexists X*\loin Object, X*\loneq o. MayAccess$^{Ind,Eve}$(o,X*) \loand\linebreak
	\ablock \ablock MayAccess$^{Dir,Eve}$(X*,o')$]$
	\linebreak\\
\textit{By contraposition,}\linebreak
M,\losigma\ \loturns\ $[$\loexists X*\loin Object, X*\loneq o. MayAccess$^{Ind,Eve}$(o,X*) \linebreak
\ablock \loand MayAccess$^{Dir,Eve}$(X*,o')] \loimplies \linebreak
		\ablock MayAccess$^{Dir,Eve}$(o,o') \loor \linebreak
	\ablock 
\hrule
\end{logic}

ShuPeng: Questions for myself...
Can I can form necessary AND sufficient conditions for MayAffect?

The power of OCap patterns hence lies in providing concrete examples of a system of cooperation that allows the existence of paths between objects for cooperation while still dictating the degree of control of one object can have over another. The logics we have developed so far illuminate the power of attenuating objects X* that can enable protection. Indeed attenuating objects feature prominently in the literature of OCap patterns which we shall see in the next section.


\subsection{Pattern 1: The JavaScript DOM Tree}
We use a JavaScript DOM Tree OCap pattern largely inspired by the example in Devriese et al.\cite{devriese2016} where they use a Kripke worlds framework to reason about the pattern. We define the following variables throughout our pattern:
\begin{itemize}
\item o,o' \loin Object
\item Node,ReNode \losubseteq Object
\item n,n' \loin Node
\item rn,rn' \loin ReNode
\end{itemize}

\begin{logic}[NodeVul]
\hrule\null
\textsc{\normalsize *Node Vulnerability}\\
\loforall o, n. MayAccess$^{Dir,Eve}$(o,n)\linebreak \ablock\ablock \loimplies \linebreak
\ablock \ablock MayAffect$^{Eve}$(o,n) \loand \linebreak
\ablock \ablock \loforall n'. MayAccess$^{Dir,Eve}$(o,n')
\end{logic}
The vulnerability of a node lies in the fact that it contains a public method \texttt{setProperty(key,value)} that will modify an internal mapping data structure. A node also has a public field \texttt{parent} that will return the capability of its parent node. Consequently, this allows an object which has the capability of any one node in the tree to navigate up to the root node (Document), and consequently navigate to all other nodes in the tree.

\begin{logic}[NodeP1]
\hrule\null
\textsc{\normalsize *Policy 1: Necessary Condition}\\
\loforall n,o, RN\losubseteq ReNode.\linebreak
\ablock Dom(RN,n) \loand\ MayAffect$^{Eve}$(o,n)\linebreak \ablock\loimplies \linebreak
\ablock \loexists rn\loin RN. MayAccess$^{Ind,Eve}$(o,rn)\linebreak
\ablock \ablock \:\:\:\: \loand\ MayAccess$^{Dir,Eve}$(rn,n)
\end{logic}
\hrule\null
This policy states that if an Object o may affect the state of a Node n, and that n is dominated(protected) by a set of ReNodes RN, then it implies that a path exists from o to some rn in RN, and that rn has strong access to n.
From Policy 1, using contraposition, we derive the relation:

\begin{logic}[NodeP1a]
\loforall n,o, RN\losubseteq ReNode.\linebreak
\ablock [ \loforall rn\loin RN. \loneg MayAccess$^{Ind,Eve}$(o,rn) \loor \linebreak
\ablock \loforall rn\loin RN. \loneg MayAccess$^{Dir,Eve}$(rn,n) ]\linebreak
\ablock \loimplies
\loneg MayAffect$^{Eve}$(o,n) \loor\ \loneg Dom(RN,n)
\end{logic}

Note that without prescribing any rules to ReNode, we can deny object o the ability to affect node n by enforcing that no path exists from o to any rn in the set RN that dominates n, which by implication is another way of saying isolation from o to n, since:
\begin{logic}[NodeP1b]
\loforall n,o. Dom(RN,n) \loand \linebreak \loforall rn\loin RN. \loneg MayAccess$^{Ind,Eve}$(o,rn) \loimplies \linebreak
\ablock \loneg MayAccess$^{Ind,Eve}$(o,n).
\end{logic}

Another implication is that we can also deny object o the ability to affect node n by enforcing \loforall rn\loin RN. \loneg MayAccess$^{Dir,Eve}$(rn,n). This is however, \textit{not} enforceable. This is because by definition a ReNode rn holds a field containing the capability of the node n it is meant to protect when the ReNode is constructed, and field that holds the capability of the node is private and constant, that cannot be subsequently changed or removed. Consequently, there must exist at least one ReNode rn in the dominating RN set that holds the capability of n:
\begin{logic}[NodeP1c]
\loexists rn \loin RN. Dom(RN,n) \loand MayAccess$^{Dir,Eve}$(rn,n)\linebreak
\ablock \loimplies \linebreak
\ablock \loneg( \loforall rn\loin RN. \loneg MayAccess$^{Dir,Eve}$(rn,n) )
\end{logic}

\textsc{Policy 2: Domination of Nodes}
\begin{logic}[NodeP2]
\end{logic}



\subsection{Pattern 2: Caretaker}
\subsection{Pattern 3: Membrane}




\textbf{Policy 1}:




%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------
\small
\bibliographystyle{plain}
\bibliography{ref}

%----------------------------------------------------------------------------------------

\end{document}

