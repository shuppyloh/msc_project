%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.4 (15/5/16)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com) with extensive modifications by
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------
\documentclass[a4paper,11pt, twoside,twocolumn]{article}
\usepackage{blindtext} % Package to generate dummy text throughout this template 

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[english]{babel} % Language hyphenation and typographical rules
\usepackage{multirow}
\usepackage{multicol}
\usepackage[left=2.5cm,right=2cm,top=2cm,bottom=2cm, hmarginratio=1:1,headheight=14pt,columnsep=15pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{graphicx}
\usepackage{enumitem} % Customized lists
\usepackage{color}
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small} % Set the abstract itself to small italic text

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
%\fancyhead[C]{Running title $\bullet$ May 2016 $\bullet$ Vol. XXI, No. 1} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section
\usepackage{titlesec}
\titleformat{name=\section}{\flushleft\bf\scshape\Large}{\thesection}{.5em}{}
\titleformat{name=\subsection}{\flushleft\bf\scshape\large}{\thesubsection}{.5em}{}
\titleformat{name=\subsubsection}{\flushleft\bf\scshape\normalsize}{\thesubsubsection}{.5em}{}

\usepackage{hyperref} % For hyperlinks in the PDF
\usepackage{amsfonts} % For more logic symbols
\usepackage{amssymb} % For more logic symbols
\usepackage[fleqn]{amsmath} % left aligned math
\usepackage{centernot} % to use not implies
\usepackage{array}
\usepackage{upgreek}
\setlength\parindent{0pt}

%----------------------------------------------------------------------------------------
%	Custom Logic Environment and  Bindings
%----------------------------------------------------------------------------------------
%eq numbering
\makeatletter
\newcommand{\eqnum}[1][]{\leavevmode\hfill\refstepcounter{equation}\label{#1}\textup{\tagform@{\theequation}}}
\makeatother
%environment formating
\newenvironment{logic}[1][]
{\begin{flushleft} \small }
{\end{flushleft}}
%logic shortcuts
\newcommand*\rot{\rotatebox{90}}
\newcommand{\loin}{$\in$}
\newcommand{\loforall}{$\forall$}
\newcommand{\loexists}{$\exists$}
\newcommand{\loand}{$\land$}
\newcommand{\loor} {$\lor$}
\newcommand{\loneq} {$\neq$}
\newcommand{\losimeq} {$\simeq$}
\newcommand{\losubseteq}{$\subseteq$}
\newcommand{\loimplies}{$\implies$}
\newcommand{\lonimplies}{$\centernot\implies$}
\newcommand{\loimpliedby}{$\Longleftarrow$}
\newcommand{\lonimpliedby}{$\centernot\Longleftarrow$}
\newcommand{\losigma}{$\upsigma$}
\newcommand{\loturns} {$\vDash$}
\newcommand{\lochi}{$\upchi$}
\newcommand{\lophi}{$\upvarphi$}
\newcommand{\lorarrow}{$\rightarrow$}
\newcommand{\lonturns} {$\nvDash$}
\newcommand{\loiff} {$\iff$}
\newcommand{\loleadsto} {$\leadsto$}
\newcommand{\lomapsto} {$\mapsto$}
\newcommand{\locup} {$\cup$}
\newcommand{\lobigcup} {$\bigcup$}
\newcommand{\lotimes} {$\times$}
\newcommand{\loneg}{$\boldsymbol \neg$}
\newcommand{\loexec}[2] {$\lfloor$#1$\rfloor _{\text{#2}}$}
\newcommand{\loconj}[1] {$\bar{\text{#1}}$}
\newcommand{\ablock} {\null\qquad}

%-----------------------
%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------
\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
\posttitle{\end{center}} % Article title closing formatting
\title{Object Capability Patterns:\\Policies and Specifications} % Article title
\author{%
\textsc{Shu-Peng Loh} \\[1ex] % Your name
\normalsize Imperial College London \\ % Your institution
\normalsize \href{mailto:shu.loh16@imperial.ac.uk}{shu.loh16@imperial.ac.uk} % Your email address
\and % if 2 authors are required, duplicate these 4 lines if more
\textsc{Sophia Drossopoulou}\\[1ex] % Second author's name
\normalsize Imperial College London \\ % Second author's institution
\normalsize \href{mailto:s.drossopoulou@imperial.ac.uk}{s.drossopoulou@imperial.ac.uk} % Second author's email address
}
\date{} % Leave empty to omit a date


\renewcommand{\maketitlehookd}{%
\begin{abstract}
\noindent  We propose a set of higher-order predicate logic to formally specify object-to-object interactions which can then be used to describe reference dynamics in an object-oriented computational model. Using these predicates, we attempt to formally specify the policies of well-established Object-Capability (OCap) patterns within the OCap literature which we have implemented in the capability-safe language Pony. We also offer some preliminary insights on how such specifications can be used in the context of a non-Ocap model by describing the security properties of a pattern built on the Ethereum smart contract programming language Solidity, which we argue implements a form of stack-based access control.\end{abstract}
}
\begin{document}
\renewcommand{\ref}[1]{\textit{\autoref{#1}}}
% Print the title
\maketitle

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{Introduction}
Recent widespread adoption of distributed ledger technology (blockchain) has created multiple decentralized, distributed computational platforms where millions of dollars are transacted over codified constructs called smart contracts\footnote{For example, as of 10 Aug 2017, Ethereum is a US\$28 billion blockchain platform with an in-built Turing-complete programming language that can be used to create and deploy such contracts.}.
The power of distributed modern computing hence lies in facilitating cooperation between multiple agents, but it comes with risk as an agent is vulnerable to \textit{unexpected} outcomes\footnote{Representing in general any outcome arising from a piece of code execution that has deviated from an agent's original intention or objective independent from code.} from participating in these smart contracts. This might generally arise from two issues: 
\begin{itemize}
\item oversight or misconception of the outcomes of executing a piece of \textit{known} code
\item failure to defend against malicious execution of \textit{unknown} code components\end{itemize}
\noindent These two issue are often closely intertwined in any system of execution that has both trusted and untrusted code components (the second issue is often a result of the first).

In recent years the Object-Capability (OCap) model has received increasing attention as a compelling approach to building robust, distributed systems that promote what Miller\cite{miller2006} calls \textit{cooperation without vulnerability}. The OCap model attemps to address these two issues by alleviating security as a separate concern from the mind of the programmer, by leveraging the object-oriented programming paradigm and imposing certain prohibitions.
%----------------------------------------------------------------------------------------
%   OCap Model
%----------------------------------------------------------------------------------------
\section{OCap Model}
The OCap model uses the reference graph of the objects as the access graph, and strictly requires objects to interact with each other only by sending messages on object references\cite{miller2003b}.
\subsection{From Capability to Object-Capability}
\subsection{OCap Languages}
\begin{itemize}
\item Joe-E (inspired by Java)
\item Emily (inspired by OCaml)
\item Caja (inspired by JavaScript)
\item E
\item Pony
\end{itemize}
\subsubsection{Language Restrictions}
\subsection{OCap Patterns}
An OCap pattern is a concrete representation of the OCap model and comprises a set of objects connected to each other by capabilities. Objects interact with each other by sending messages on capabilities. An OCap pattern may be visualised as a directed graph---nodes represent objects, and each edge from an object \textit{o} to another \textit{o'} represents \textit{o} holding a capability that allows it to directly access \textit{o'}.
%----------------------------------------------------------------------------------------
%   Formal Specifications
%----------------------------------------------------------------------------------------
\section{Formal specifications}
\subsection{Definitions}\noindent
We borrow liberally the definitions of runtime state, module and arising configurations from the appendix of \cite{drossopoulou2015b}.\\
\textbf{Runtime state:}
 \losigma\ consists of a stack frame \lophi, and a heap \lochi. A stack frame is a mapping from receiver (this) to its address, and from the local variables (VarId) and parameters (ParId) to their values. Values are integers, the booleans true or false, addresses, or null. The heap maps addresses to objects. Objects are tuples consisting of the class of the object, and a mapping from field identifiers onto values.
\begin{logic}[Runtime state]
\losigma\ \loin\ state = frame \lotimes\ heap \\
\lophi \loin\ frame = StackId $\rightarrow$ val \\
\lochi \loin\ heap = addr $\rightarrow$ object \\
v \loin\ val = \{\texttt{null}, \texttt{true}, \texttt{false}\} \locup\ \textit{addr} \locup\ $\mathbb{N}$ \\
StackId = \{\textit{this}\} \locup\ VarId \locup\ ParId \\
object = ClassId \lotimes (FieldId $\rightarrow$ val)
\end{logic}
\textbf{Module:}
\begin{logic}[Module]
M \loin\ Module = ClassId \locup\ SpecId\linebreak\ablock\qquad\qquad\quad $\rightarrow$ \linebreak
\ablock \qquad \qquad \quad (ClassDescr \locup\ Specification)
\end{logic}

\textbf{Reach and Execution:}\\
\begin{logic}[Reach and Execution]\end{logic}



\textbf{Arising Configurations}\\
\begin{logic}[Arising]\end{logic}



\textbf{Domination:}\\
\begin{logic}[Domination]\end{logic}



\subsubsection{MayAccess Definitions}
We define in total four flavours of MayAccess predicates that describe the relation between two entities in a system (of arity 2 that represent the identifiers of these entities). These four flavours represent a combination of space (distance) and time (state):
\begin{itemize}
\item distance: directly ($Dir$) or indirectly ($Ind$)
\item state: now ($Now$) or eventually ($Eve$)
\end{itemize}
and are broad enough to describe both non-OCap and OCap models:
\begin{logic}[MayAccessDirNow]
M,\losigma\ \loturns\ MayAccess$^{Dir,Now}$(x,e) \loiff \linebreak
\ablock \loexists f. \loexec{x.f}{\losigma} = \loexec{e}{\losigma}
\loor \linebreak
\ablock (\losigma(this) = \loexec{x}{\losigma} \loand\ \loexists y. \losigma(y) = \loexec{e}{\losigma})
\end{logic}
\begin{logic}[MayAccessDirEve]
 M,\losigma\ \loturns\ MayAccess$^{Dir,Eve}$(x,e) \loiff \linebreak
\ablock \loexists \losigma' \loin Arising(M,\losigma).\linebreak
\ablock M,\losigma'\ \loturns\ MayAccess$^{Dir,Now}$(x,e) 
\end{logic}
\begin{logic}[MayAccessIndNow]
M,\losigma\ \loturns\ MayAccess$^{Ind,Now}$(x,e) \loiff \linebreak
\ablock \loexists \loconj{f}. \loexec{x.\loconj{f}}{\losigma} = \loexec{e}{\losigma}
\loor \linebreak
\ablock (\losigma(this) = \loexec{x}{\losigma} \loand\ \loexists y. \losigma(y.\loconj{f}) = \loexec{e}{\losigma})
\end{logic}
\begin{logic}[MayAccessIndEve]
M,\losigma\ \loturns\ MayAccess$^{Ind,Eve}$(x,e) \loiff \linebreak
\ablock \loexists \losigma' \loin Arising(M,\losigma).\linebreak
\ablock M,\losigma'\ \loturns\ MayAccess$^{Ind,Now}$(x,e) 
\end{logic}

A note on \textit{f} and \textit{\loconj{f}}\ : While f can considered as a field, it can also represent a method that returns a val.
Similarly \loconj{f} can be considered a series of fields, or methods that return a val, or a combination of both.\\

We surmarise the relationships between the four flavours of MayAccess in \ref{MayAccessTable}:
\begin{table}[hbtp]
\small
\caption{MayAccess$^{*,*}$(x,e) Relations}
\centering
\begin{tabular*}{\linewidth}{c|ccc}\toprule
& \bf Now & & \bf Eventually\\
\hline
\multirow{5}{*}{\rot{\bf Indirect \enspace Direct \:}} & \multirow{2}{*}{MayAccess$^{Dir,Now}$} & \loimplies & \multirow{2}{*}{MayAccess$^{Dir, Eve}$} \\
& & \lonimpliedby &  \\
& \rot{\loimpliedby} \rot{\lonimplies}& &\rot{\loimpliedby} \rot{\lonimplies} \\
& \multirow{2}{*}{MayAccess$^{Ind,Now}$} & \loimplies & \multirow{2}{*}{MayAccess$^{Ind, Eve}$} \\
& & \lonimpliedby &\\
\label{MayAccessTable}
\end{tabular*}
\end{table}

Let us assume that both x and e are well-defined. Note that without imposing any further assumptions (such as those from the OCap model), we have defined \textit{both} MayAccess$^{Dir,Now}$(x,e) and MayAccess$^{Ind,Now}$(x,e) to mean forms of very weak access---that a directed path exists from x to e, but we do \textit{not} imply that such a path is traverseable by x (it might or might not be traverseable). Indeed, these definitions by themselves represent mere \textit{possibilities} of interaction (or possible authorities), they do \textit{not} represent that interaction (or authority) would succeed. The difference between MayAccess$^{Dir,Now}$(x,e) and MayAccess$^{Ind,Now}$(x,e) is only the computational distance between x and e on the reference graph, where the latter involves possibly intermediate entities (or objects in an object-oriented model).\\

What do the definitions mean then for non-OCap and OCap models in an object-oriented world? Again, let us assume both o and o' are well-defined, valid object references. In non-OCap models, the possible presence of a global ambient authority means the predicates above say \textit{nothing} about whether any interaction between an object o and o' would succeed. This is true even if o possesses directly the reference of o', where MayAccess$^{Dir,Now}$(o,o') holds. For all we know, we could easily have in a non-OCap language a feature to completely restrict access to o' using a global ambient authority, such that any object in the programming world which possesses references of o' cannot use them, and all paths leading to o' represent merely possibilities of interaction, but from which no authority can possibly arise.\\

Could we say more about OCap systems? In OCap systems, there can be no global ambient authority so that an object reference by itself represents both the designation and the authority to use the object. This therefore leads us to be able to make a crucial distinction between MayAccess$^{Ind,Now}$(o,o') and MayAccess$^{Dir,Now}$(o,o') in the OCap model:
\begin{itemize}
\item MayAccess$^{Ind,Now}$(o,o') means---\textit{only}\\
\ablock 1. a directed path from o to o' exists\\
\ablock\ablock (possible authority)
\item MayAccess$^{Dir,Now}$(o,o') means---\textit{both}\\
\ablock 1. a directed path from o to o' exists\\
\ablock\ablock (possible authority) \textit{and}\\
\ablock 2. o's authority to use o' \textit{will} succeed
\end{itemize}
We elaborate the distinction with the following OCap example where there is a particular state \losigma\ of the system where, o$_1$.next points to o$_2$, and o$_2$.next points to o$_3$. o$_2$.next is a private method that can only be called internally by o$_2$. In this example, M,\losigma ~\loturns ~MayAccess$^{Ind,Now}$(o$_1$,o$_3$) holds, regardless of whether o$_2$.next is traverseable by o$_1$. We say here that a path from o$_1$ to o$_3$ exists, but is not traverseable by o$_1$. On the other hand, MayAccess$^{Dir,Now}$(o$_1$,o$_3$) does not hold true, because o$_3$ is not reachable from $o_1$ in a single step---o$_2$ sits between them on the reference graph as an intermediate object, and can possibly prevent or allow traversal from o$_1$ to o$_3$ (in this example, o$_2$ prevents such a traversal).\\

What does it mean then for MayAccess$^{Dir,Now}$(*,*) to hold in an OCap model? From the same example, MayAccess$^{Dir,Now}$(o$_1$,o$_2$) holds and implies a stronger form of access---it means that a path exists from o$_1$ to o$_2$, and that such a path \textit{is} traverseable. This is because, by the definition of the predicate and configuration of the example, the object reference of o$_2$ exists within o$_1$'s state. Therefore, o$_2$ is guaranteed therefore to be accessible, and its authority exercisable, by o$_1$, without the interference of any ambient authority. Notice how this o$_1$-o$_2$ relationship differs from the o$_1$-o$_3$ relationship, where o$_1$ cannot guarantee that it can exercise the authority of o$_2$.next which points to o$_3$, since o$_2$.next does not exist within o$_1$'s state---it is possible that o$_2$.next is protected by x$_2$ through encapsulation and data-hiding.\\

Within an OCap model, we can now be convinced that the stronger
\begin{logic}
MayAccess$^{Dir,Now}$(o$_1$,o$_2$) \losimeq \linebreak
\ablock o$_1$ has the capability of o$_2$\end{logic}
while the weaker MayAccess$^{Ind,Now}$(o$_1$,o$_3$) does not say anything about whether o$_1$ has the capability of o$_3$, but that only a directed path exists. It does however, represent a necessary condition for capability.
\begin{logic}
MayAccess$^{Ind,Now}$(o$_1$,o$_3$) \losimeq\ \linebreak
\ablock there is a directed path from o$_1$ to o$_2$\linebreak
\\
o$_1$ has the capability of o$_3$ \loimplies \linebreak
\ablock MayAccess$^{Ind,Now}$(o$_1$,o$_3$)\end{logic}
\subsubsection{MayAffect Definitions}
With our access predicates in place, we introduce a set of predicates that describe changes to the state of a system. Again, we highlight that these predicates are broad enough to describe both non-OCap and OCap models. 
\begin{logic}
M,\losigma\ \loturns\ MayAffect$^{Now}$(x,e) \loiff \linebreak
\ablock \loexists \loconj{m},\loconj{a},\losigma'. x.\loconj{m}(\loconj{a}) \loleadsto\ \losigma' \loand \loexec{e}{\losigma} \loneq \loexec{e}{\losigma'}
\linebreak \\
M,\losigma\ \loturns\ MayAffect$^{Eve}$(x,e) \loiff \linebreak
\ablock \loexists \losigma' \loin Arising(M,\losigma).\linebreak
\ablock \loexists \loconj{m},\loconj{a},\losigma'. x.\loconj{m}(\loconj{a}) \loleadsto\ \losigma' \loand \loexec{e}{\losigma} \loneq \loexec{e}{\losigma'}
\linebreak \\
\textit{If e is an object:} \\
\loforall e\loin Object. \loexec{e}{\losigma} \loneq \loexec{e}{\losigma'} \loiff \linebreak
\ablock \loexists f. \loexec{e.f}{\losigma} \loneq \loexec{e.f}{\losigma'}
\end{logic}

\begin{table}[hbtp]
\caption{MayAffect(o,o') Relations in OCap}
\centering
\begin{tabular*}{\linewidth}{ccc}\toprule
\multirow{2}{*}{MayAffect$^{Now}$} & \loimplies & \multirow{2}{*}{MayAffect$^{Eve}$} \\
& \lonimpliedby &  \\
\bottomrule
\end{tabular*}
\end{table}

\subsection{OCap Security Implications}


\subsubsection{What is protection?}
In an object-oriented world\footnote{
To simplify our discussion, we work with the variables \{o,o'\}\loin Object for this entire section.}
, security concerns between objects are often a question of whether what one object can do to another object in \textit{any} eventual state of a system. Because an object encapsulates both internal state and behaviour, strictly speaking, security of an object should govern over both the integrity of the object's fields (internal state) and whether the objects' methods can be called (behaviour). Our predicates are broad enough to enable a discussion of both protection of state (MayAffect$^{Eve}$) and behaviour (MayAccess$^{Dir,Eve}$)\footnote{ Our MayAccess$^{Dir,Eve}$ is not weak enough to reason specifically which behaviours can be called. This is however not a big issue in \textit{pure} OCap systems, where often giving away the capability of an object typically means allowing \textit{all} public behaviours of the object to be called without distinction.}. We emphasize however that protecting either state or behaviour of an object, does \textit{not} necessarily imply the other. In fact, a common feature in OCap patterns is being able to protect a sensitive object's behaviours (they cannot be called directly by untrusted objects), but at the some allowing the same untrusted objects to modify the object's state in some controlled way.\\

There are however, some flexibility in working with objects, that allows us to simplify our discussion and work with only a broad definition of state protection in terms of our MayAffect$^{Eve}$ predicate, \textit{without} thinking too much about specific fields of the object we want to protect or the protection of behaviour. Moving away from our broad definition of whether an object may be affected (we defined it as being able to change at least one field of the object), to more precise spcifications of which particular field(s) of the object may be affected, should be trivial. We can in theory also stay and reason within our framework by separating the particular concerned field(s) of the object into separately encapsulated objects. We merely have to be careful as to \textit{which} object's state we want to protect. Furthermore, in theory one can easily introduce a field within an object that behaves like a 'signal' which would be modified whenever a specified behaviour is called. Preventing a particular behaviour to be called by an untrusted object then becomes equivalent to denying the untrusted object the ability to modify the particular state of the signal field of the object.\\

With these simplifications, protection for us then becomes solely a matter of whether we can allow or deny an object to modify the state of another. To help us reason about protection, we first formalize our assumptions and the rules of OCap, using our predicates, to help guide us in constructing our necessary conditions in \ref{ocaprules}. In the following \ref{protection} below we build the neccessary conditions for MayAffect$^{Eve}$, where MayAffect$^{Eve}$ is placed in the antecedent, and we examine which of the family of MayAccess predicates is placed in the consequent. 

\subsection{Formal specifications of OCap Rules}\label{ocaprules}

\textbf{Rule 1: Objects can only interact with each other through sending messages on capabilities.}
We begin our reasoning of protection in our OCap model, by first re-asserting the necessary but not sufficient path condition of capability, and calling it \textsc{pec}. By definition of our predicates, an object having a capability of o' implies object o having a path to o', but not vice-versa:
\begin{logic}
\hrule\null
\textsc{\normalsize *Path-Execution Connectivity (PEC)}\\
M,\losigma\ \loturns\ MayAccess$^{Dir,Now}$(o,o') \loimplies \linebreak
\ablock \ablock  MayAccess$^{Ind,Now}$(o,o')
\linebreak \\
\textit{By contraposition,}\linebreak
M,\losigma\ \loturns\ \loneg MayAccess$^{Ind,Now}$(o,o')\loimplies \linebreak
\ablock \ablock \loneg MayAccess$^{Dir,Now}$(o,o')
\linebreak
\hrule
\end{logic}
Note also that \textsc{pec} is a direct intepretation from Rule 1, since rule 1 says owning a capability is the only way of sending messages to another object, and therefore implies a path between the objects.\\

\textbf{Rule 2: Objects cannot forge capabilities, and only connectivity begets connectivity.}
\begin{logic}
\hrule\null
\textsc{\normalsize *Global Path Existence (GPE)}\\
M,\losigma\ \loturns\ $[$\loexists Y*\loin{Obj}. MayAccess$^{Ind,Now}$(Y*,o')$]$\linebreak
\ablock \loiff\linebreak
\ablock $[$\loexists X*\loin{Obj}. MayAccess$^{Dir,Now}$(X*,o')$]$
\linebreak\\
\textit{By contraposition,}\linebreak
M,\losigma\ \loturns\ $[$\loforall X*\loin{Obj}. \loneg MayAccess$^{Dir,Now}$(X*,o')$]$\linebreak
\ablock \loiff\linebreak
\ablock $[$\loforall Y*\loin{Obj}. \loneg MayAccess$^{Ind,Now}$(Y*,o')$]$\linebreak
\hrule
\end{logic}
In addition to path being a necessary condition for capability, \textsc{gpe} gives us an additional new relation between the two concepts over the entire system. \textsc{gpe} says that in a given system of objects, $iff$ there exists an object Y* which has a path to o', then there exists an object X* that has the capability of o'. Looking from the left to right direction, since the path from Y* to o' exists, then there must exist an object X* with a capability of o' so that the path from Y* to o' is well-established. Moving from the right to left direction, \textsc{gpe} says that if an object X* has a capability then there exist an object Y* with a path to o', and this can be proven from \textsc{pec} or by definition when (X*==Y*). The contraposition result of \textsc{gpe} says that we can prevent all paths to o' through one of these conditions through denying all direct paths leading into o'.\\

However, \textsc{gpe} only postulates the existence of some object with some capability iff there exists some object with some path, and says nothing about how the objects are connected. From the connectivity begets connectivity rule, \textsc{pec}, and \textsc{gpe}, we construct global path-execution relationships over the entire system:
\begin{logic}
\hrule\null
\textsc{\normalsize *Global Path-Execution Connect. (GPEC)}\\
M,\losigma\ \loturns\ MayAccess$^{Ind,Now}$(o,o')\linebreak
\ablock \loiff\linebreak
\ablock \loexists X*\loin{Obj}. $[$MayAccess$^{Ind,Now}$(o, X*) \loand\linebreak
\ablock \ablock \ablock \quad MayAccess$^{Dir,Now}$(X*,o')$]$
\linebreak\\
\textit{By contraposition,} \\
M,\losigma\ \loforall X*\loin{Obj}. $[$\loneg MayAccess$^{Ind,Now}$(o, X*) \loor\linebreak
\ablock \ablock \ablock \quad \loneg MayAccess$^{Dir,Now}$(X*,o')$]$\linebreak
\ablock \loiff\linebreak
\ablock \loneg MayAccess$^{Ind,Now}$(o,o')\linebreak
\hrule
\end{logic}
\textsc{gpec} introduces an intermediate object X* between o and o' that makes explicit the missing connection in \textsc{gpe}.\\

The contraposition result of \textsc{gpec} says that for there to be no paths from o to o' these configurations must hold:
\begin{itemize}\setlength\itemsep{0.5em}
\item if there is some object x that o has a path to in \losigma, then x cannot have a path to o' in \losigma.
\item if there is some object x that has a path to o' in \losigma, then o cannot have a path to x in \losigma.
\end{itemize}



The power in \textsc{gpec} lies in the recursive predicate MayAccess$^{Ind,Now}$(o, X*) that can eventually be expanded into a set of MayAccess$^{Dir,Now}$ predicates that finishes with terminating predicate MayAccess$^{Ind,Now}$(o, o), where the terminating predicate will always be true, unless the object o does not exist in \losigma.
We now look for a relation between a path configuration at a state \losigma\ ($Now$) and eventual path configurations in states \losigma' arising from \losigma\ ($Eve$).\vfill
\begin{minipage}[b]{\linewidth}
\begin{logic}
\hrule\null
\textsc{\normalsize *Eventual Path Connectivity 1 (EPC1)}\\
M,\losigma\ \loturns\ MayAccess$^{Ind,Eve}$(o,o')\linebreak
\ablock \loimplies\linebreak
\ablock \loexists X*\loin Obj. $\{[$MayAccess$^{Ind,Now}$(o,X*)\linebreak
\ablock \ablock \ablock \ablock\loor \linebreak
\ablock \ablock \ablock \quad\: MayAccess$^{Dir,Now}$(X*,o)$]$\linebreak
\ablock \ablock \ablock \quad \loand \linebreak
\ablock \ablock \ablock \quad MayAccess$^{Ind,Eve}$(X*,o')$\}$
\linebreak \\
\textit{By contraposition,}\linebreak
M,\losigma\ \loturns\ \linebreak
\ablock \loforall X*\loin Obj. $\{[$\loneg MayAccess$^{Ind,Now}$(o,X*)\linebreak
\ablock \ablock \ablock \ablock \quad \loand \linebreak
\ablock \ablock \ablock \quad\: \loneg MayAccess$^{Dir,Now}$(X*,o)$]$\linebreak
\ablock \ablock \ablock \quad \loor \linebreak
\ablock \ablock \ablock \quad \loneg MayAccess$^{Ind,Eve}$(X*,o')$\}$\linebreak
\ablock \loimplies\linebreak
	\ablock\loneg MayAccess$^{Ind,Eve}(o,o')$\linebreak
\hrule
\end{logic}
\end{minipage}
\textsc{epc1} has the meaning that if an object o has an eventual path to o' in some arising state \losigma', then there must exist an object X* that has an eventual path to o', and there must exist a way for o to have a path to X* in \losigma'. o either must already have a path to X* in \losigma, or that it will eventually receive the capability of X* in \losigma'. \textsc{epc1} is actually a formal representation of connectivity begets connectivity across time:

\begin{itemize}
\item \textbf{Initial Conditions or Endowment:} o has an existing path to o' in \losigma, therefore X* refers to o'
\item \textbf{Parenthood:} since o can create o' in some arising \losigma', then o can also create o' in \losigma, X* refers to o'
\item \textbf{Introduction:} o will only obtain the path to o' in some arising \losigma', therefore X* refers to an object that is not the same object as o (X*\loneq o). 
\end{itemize}

Note that for o to have an eventual path to o', we require only o to have an eventual path to X* since we have stated that X* will have an eventual path to o'. If o already has a path to X* in \losigma\ then we know o can reach X* in \losigma'. If not, the capability of X* must be introduced to o. For X* to introduce itself, X* must have the capability of o in \losigma', and the only way we can guarantee this is to have X* possess the capability of o in \losigma. Well, what if the capability of X* is introduced by some \textit{other} object \~X*? Note that in such a case, \~X* will have the capability of X*, and will therefore also be able to eventually have a path to o'. Also \~X* must also be able to introduce itself to o. There is hence no logical difference between \~X* and X* in our formal description and \~X* might simply be referred to as X*.\\

The contraposition result of \textsc{epc1} says that for there to be no eventual paths from o to o' these configurations must hold:
\begin{itemize}\setlength\itemsep{0.5em}
\item if there is some object x that o has a path to in \losigma, then x cannot have an eventual path to o'
\item if there is some object x that possesses the capability of o in \losigma, then x cannot have an eventual path to o'
\end{itemize}
Note that object x can refer to the same object as o'.
There is one final critical result from \textsc{epc1}.
Notice how, there is a 'recursive' MayAccess$^{Ind,Eve}$(X*,o') in our condition for MayAccess$^{Ind,Eve}$(o,o').
This allows us to recursively expand the condition to incorporate \textit{all} X* intermediate objects in the path leading to o'. This recursive expansion gives us both MayAccess$^{Dir,Now}$ and MayAccess$^{Ind,Now}$ predicates, where the terminating MayAccess$^{Ind,Eve}$(o',o') always returns true if o' exists. This result allows us to define MayAccess$^{Ind,Eve}$(X*,o') in a configuration of paths completely based in \losigma.\\

What about capabilities? Using \textsc{gpec}, we can always expand MayAccess$^{Ind, Now}$(o,X*) into a set of MayAccess$^{Dir, Now}$ predicates that terminate with MayAccess$^{Ind, Now}$(o,o) which is always true if o exists. The final result we will get is a configuration based purely on MayAccess$^{Dir, Now}$ predicates. We expand \textsc{epc1} into \textsc{epc2} to illustrate:

\begin{logic}
\hrule\null
\textsc{\normalsize *Eventual Path Connectivity 2 (EPC2)}\\
M,\losigma\ \loturns\ MayAccess$^{Ind,Eve}$(o,o')\linebreak
\ablock \loimplies\linebreak
\ablock \loexists X*\loin Obj.$\{$\linebreak
\ablock \ablock $[$\null
\textcolor{red}{\loexists X$^1$\loin{Obj}. MayAccess$^{Ind,Now}$(o, X$^1$) \loand\linebreak
\ablock \ablock \ablock \ablock \quad MayAccess$^{Dir,Now}$(X$^1$,X*)\linebreak
}
\ablock \ablock \quad \loor \linebreak
\ablock \ablock MayAccess$^{Dir,Now}$(X*,o)$ ]$\linebreak
\ablock \ablock \loand \linebreak
\textcolor{blue}{
\ablock \ablock \loexists Y*\loin Obj.$\{[$MayAccess$^{Ind,Now}$(X*,Y*)\linebreak
\ablock \ablock \ablock \ablock \quad \quad \loor \linebreak
\ablock \ablock \ablock \ablock \quad MayAccess$^{Dir,Now}$(Y*,X*)$]$\linebreak
\ablock \ablock \ablock \ablock \quad \loand \linebreak
\ablock \ablock \ablock \ablock \quad MayAccess$^{Ind,Eve}$(Y*,o')$\}$
}\linebreak
\ablock \ablock $\}$
\linebreak \\
\textit{By contraposition,}\linebreak
M,\losigma\ \loturns\ \linebreak
\ablock \loforall X*\loin Obj.$\{$\linebreak
\ablock \quad $[$\null
\textcolor{red}{\loforall X$^1$\loin{Obj}. \loneg MayAccess$^{Ind,Now}$(o,X$^1$) \loor\linebreak
\ablock \ablock \ablock \ablock \loneg MayAccess$^{Dir,Now}$(X$^1$,X*)\linebreak
}
\ablock \ablock \quad \loand \linebreak
\ablock \quad \loneg MayAccess$^{Dir,Now}$(X*,o)$ ]$\linebreak
\ablock \ablock \loor \linebreak
\textcolor{blue}{
\ablock \loforall Y*\loin Obj. $\{[$\loneg MayAccess$^{Ind,Now}$(X*,Y*)\linebreak
\ablock \ablock \ablock \ablock \quad \loand \linebreak
\ablock \ablock \ablock \quad\: \loneg MayAccess$^{Dir,Now}$(Y*,X*)$]$\linebreak
\ablock \ablock \ablock \quad \loor \linebreak
\ablock \ablock \ablock \quad \loneg MayAccess$^{Ind,Eve}$(Y*,o')$\}$
}\linebreak
\ablock \loimplies\linebreak
	\ablock\loneg MayAccess$^{Ind,Eve}(o,o')$\linebreak
\hrule
\end{logic}

To give a concrete example, let us assume a simple system with only three objects, o, x, o'.
\begin{logic}
\hrule\null
\textsc{\normalsize *Eventual Path Example}\\
M,\losigma\ \loturns\ MayAccess$^{Ind,Eve}$(o,o')\linebreak
\ablock \loimplies\linebreak
\ablock \ablock $[$\null
\textcolor{red}{MayAccess$^{Ind,Now}$(o,o) \loand\linebreak
\ablock \ablock \quad MayAccess$^{Dir,Now}$(o,x)\linebreak
}
\ablock \ablock \quad \loor \linebreak
\ablock \ablock MayAccess$^{Dir,Now}$(x,o)$ ]$\linebreak
\ablock \ablock \loand \linebreak
\textcolor{blue}{
\ablock \ablock $\{[$
\textcolor{red}{MayAccess$^{Ind,Now}$(x,x) \loand\linebreak
\ablock \ablock \quad MayAccess$^{Dir,Now}$(x,o')\linebreak}
\ablock \ablock \quad \quad \loor \linebreak
\ablock \ablock \quad MayAccess$^{Dir,Now}$(o',x)$]$\linebreak
\ablock \ablock \quad \loand \linebreak
\ablock \ablock \quad MayAccess$^{Ind,Eve}$(o',o')$\}$
}\linebreak
\ablock \ablock $\}$
\linebreak \\
\hrule
\end{logic}
In the example, we make concrete \textsc{epc2} using X* = x and Y* = o', where the expansion terminates at the three predicates, MayAccess$^{Ind,Now}$(o,o), MayAccess$^{Ind,Now}$(x,x) and MayAccess$^{Ind,Eve}$(o',o'). Let us assume o, x, and o' always exists, such that these predicates would return true. This example then illustrates an eventual path from o to o' can only exist if one of these four conditions in \losigma\ hold:
\begin{itemize}\setlength\itemsep{0.5em}
\item o has the capability of x, and x has the capability of o'
\item o has the capability of x, and o' has the capability of x
\item x has the capability of o, and x has the capability of o'
\item o has the capability of x, and x has the capability of o'
\end{itemize}
Note how, these four configurations are direct capability configurations at \losigma, but allows us to reason about whether a potential path from o to o' can exist in some arising state \losigma' from \losigma. This is expressed more succintly below in \textsc{epc3***}

\begin{logic}
\hrule\null
\textsc{\normalsize *Eventual Path Connectivity 3*** (EPC3***)}\\
M,\losigma\ \loturns\ MayAccess$^{Ind,Eve}$(o,o')\linebreak
\ablock \loimplies\linebreak
\ablock \loexists X*, x$^{1...n}$\loin Obj.$\{[$MayAccess$^{Ind,Now}$(o,o)\linebreak
\ablock \ablock \ablock \ablock \ablock \loand\linebreak
\ablock \ablock \ablock \ablock \ablock MayAccess$^{Dir,Now}$(o,x$^1$)\linebreak
\ablock \ablock \ablock \ablock \ablock $\vdots$\linebreak
\ablock \ablock \ablock \ablock \ablock MayAccess$^{Dir,Now}$(x$^{n-1}$,x$^n$)\linebreak
\ablock \ablock \ablock \ablock \ablock \loand\linebreak
\ablock \ablock \ablock \ablock \ablock MayAccess$^{Dir,Now}$(x$^n$,X*)$]$\linebreak
\ablock \ablock \ablock \ablock \quad\: \loor \linebreak
\ablock \ablock \ablock \ablock \quad\: MayAccess$^{Dir,Now}$(X*,o)$\}$\linebreak
\ablock \ablock \ablock \ablock \loand \linebreak
\ablock \ablock \ablock \quad MayAccess$^{Ind,Eve}$(X*,o')\linebreak\\
\ablock \textit{where if o exists in \losigma,} \linebreak
\ablock \loturns\ MayAccess$^{Ind,Now}$(o,o) is true\linebreak\linebreak\
\ablock \textit{where if o' exists in some \losigma',}\linebreak
\ablock \loturns\ MayAccess$^{Ind,Eve}$(o',o') is true\linebreak
\hrule
\hrule
\end{logic}



So far we have developed results for paths from o to o', but what about a direct path from o to o' (what are the conditions such that o will have the direct capability of o' eventually)? Luckily, we only need construct \textsc{eec} from \textsc{epc1}, the only difference being we now require the path from o to X* in \textsc{epc1} to be traversable.

\begin{logic}
\hrule\null
\textsc{\normalsize *Eventual Execution Connectivity (EEC)}\\
M,\losigma\ \loturns\ MayAccess$^{Dir,Eve}$(o,o')\linebreak
\ablock \loimplies\linebreak
\ablock \loexists X*\loin Obj.$[($MayAccess$^{Dir,Now}$(o,X*) \loor \linebreak
\ablock \ablock \ablock \ablock MayAccess$^{Dir,Now}$(X*,o)$)$\linebreak
\ablock \ablock \ablock \ablock \loand \linebreak
\ablock \ablock \ablock \ablock MayAccess$^{Dir,Eve}$(X*,o')$]$
\linebreak \\
\textit{By contraposition,}\linebreak
M,\losigma\ \loturns\ 
\loforall X*\loin Obj. $\{[$\loneg MayAccess$^{Dir,Now}$(o,X*) \loand \linebreak
\ablock \ablock \ablock \ablock \quad \loneg MayAccess$^{Dir,Now}$(X*,o)$]$\linebreak
\ablock \ablock \ablock \ablock \loor \linebreak
\ablock \ablock \ablock \ablock \loneg $[$MayAccess$^{Dir,Eve}$(X*,o')$]\}$\linebreak
\ablock \loimplies\linebreak
	\ablock\loneg MayAccess$^{Dir,Eve}(o,o')$\linebreak
\hrule
\end{logic}
The power of \textsc{eec} is similar to \textsc{epc1}\ in that it allows an arbitrary recursive expansion of the MayAccess$^{Dir,Eve}$(X*,o') till the terminating MayAccess$^{Dir,Eve}$(o',o').\\

We now turn our attention formalizing Ocap state changes rules in the system.\\

\subsection{Protection}\label{protection}
With our formalizations of OCap rules in place, we can now reason about enforcing protection. In this subsection we focus on finding the necessary conditions for the weaker predicate MayAffect$^{Eve}$ rather than MayAffect$^{Now}$ in the antecedent. This is because negation on both sides of the implication, would yield a stronger \loneg MayAffect$^{Eve}$ in the consequent. In practical terms, if we are concerned with the protection of o' from o, it is also often not very useful to have a policy where \loneg MayAffect$^{Now}$(o,o') holds but \loneg MayAffect$^{Eve}$(o,o') does not. Furthermore, by ensuring \loneg MayAffect$^{Eve}$(o,o') holds, we can also ensure \loneg MayAffect$^{Now}$(o,o') holds since by contraposition:

\begin{logic}
$[$MayAffect$^{Now}$(o,o') \loimplies MayAffect$^{Eve}$(o,o')$]$\linebreak
\ablock \loimplies\linebreak
$[$\loneg MayAffect$^{Eve}$(o,o') \loimplies \loneg MayAffect$^{Now}$(o,o')$]$\\
\end{logic}

Furthermore, in building the necessary conditions for the predicate MayAffect$^{Eve}$, we are also more concerned with finding some structure that contains the configuration of MayAccess$^{*,Now}$, rather than MayAccess$^{*,Eve}$. This is because it is much easier to prove a configuration of relations that holds in \textit{one} specific state than think about whether a configuration holds in \textit{all} possible eventual states, which makes the former much easier to implement.\\

\textbf{Rule 3: Objects may have private encapsulation of state and behaviour}\\
To begin, we make clean in our reasoning that all fields in our objects can only be declared private. Consequently, this implies the necessary condition that an object's state can only be modified if one of it's behaviour is called, either by itself or one other object in the system that holds its capability. This is also implied by the OCap rule that there is no ambient authority that can interact with any object's behaviour.
\begin{logic}
\hrule\null
\textsc{\normalsize *Private Fields Assumption (PFA)}\\
M,\losigma\ \loturns\ \loexists X*\loin Obj. MayAffect$^{Now}$(X*,o') \loimplies \linebreak
	\ablock \ablock \loexists Y*\loin Obj. MayAccess$^{Dir,Now}$(Y*,o')
\linebreak \\
\textit{By contraposition,}\linebreak
M,\losigma\ \loturns\ 	\loforall Y*\loin Obj. \loneg MayAccess$^{Dir,Now}$(Y*,o') \loimplies \linebreak
	\ablock \ablock \loforall X*\loin Obj. \loneg MayAffect$^{Now}$(X*,o')
\linebreak
\hrule
\end{logic}

\textsc{pfa} means that in order for an object o' to change, it must be done through some object Y* calling its behaviour (Y* can refer to the same object as X*). Equivalently, denying all objects in the system the ability to call an object's behaviour implies that no object can modify the object's state.\\



\begin{logic}
\hrule\null
\textsc{\normalsize *Global State Change Existence (GSCE)}\\
M,\losigma\ \loturns\ $[$\loexists X*\loin{Obj}. MayAffect$^{Now}$(X*,o')$]$\linebreak
\ablock \loimplies \linebreak
\ablock $[$\loexists Y*\loin{Obj}. MayAccess$^{Dir,Now}$(Y*,o')$]$\linebreak
\ablock \loimplies \linebreak
\ablock $[$\loexists Z*\loin{Obj}. MayAccess$^{Ind,Now}$(Z*,o')$]$
\linebreak\\
\hrule
\end{logic}
\textsc{gsce} can be derived from our predicate definitions, and makes explicit the connection betwen state change, paths, and capabilities. The first implication states that if an object can change the state of o', then there must exist an object in the system that holds the capability of o'. The second implication is that there must exist an object in the system that holds a path to o'.
We view reasoning about state change as reasoning about protection, which we elaborate in the next subsection.

\subsubsection{Protection is path-denial}
\begin{logic}
M,\losigma\ \loturns\ MayAffect$^{Eve}$(o,o') \lonimplies 
MayAccess$^{Dir,Eve}$(o,o')\linebreak
\\
M,\losigma\ \loturns\ MayAffect$^{Eve}$(o,o') \loimplies 
MayAccess$^{Ind,Eve}$(o,o')\linebreak
\\
M,\losigma\ \loturns\ \loneg MayAccess$^{Ind,Eve}$(o,o') \loimplies 
\loneg MayAffect$^{Eve}$(o,o')\linebreak
\\
M,\losigma\ \loturns\ MayAccess$^{Dir,Eve}$(o,o') \loimplies 
MayAccess$^{Ind,Eve}$(o,o')\linebreak
\\
M,\losigma\ \loturns\ \loneg MayAccess$^{Ind,Eve}$(o,o') \loimplies 
\loneg MayAccess$^{Dir,Eve}$(o,o') \loand\ \loneg MayAffect$^{Eve}$(o,o')\linebreak
\end{logic}
We make the important result that protection of an object's state is path denial to the object, where path is a necessary condition for an object to affect another object. An object o having the capability of o' is \textbf{NOT} a necessary condition for o to modify the state of o'. However, the existence of \textit{some} object X* (that can refer to o, or other objects) having the capability of o', is a necessary condition for o to modify o'. See \textsc{ncc1} and \textsc{ncc2} below which illustrates this. This is precisely why attenuating objects are so powerful and useful in OCap patterns. We can always deny o the capability of o', but still allow o to modify o' in some protected way. To say it in another way, denial of paths is much stronger, as it implies protection \textit{and} denial of capability, but denial of capability does \textit{not} imply protection and denial of paths.\\

\begin{logic}
\hrule\null
\textsc{\normalsize *Necessary Capability Condition 1 (NCC1)}\\
M,\losigma\ \loturns\ MayAffect$^{Eve}$(o,o') \loimplies\linebreak
	\ablock \loexists X*\loin{Obj}. MayAccess$^{Dir,Eve}$(X*,o') 
\linebreak\\
\textit{By contraposition and quantifier equivalence,}\linebreak
M,\losigma\ \loturns\ \loforall X*\loin{Obj}. \loneg MayAccess$^{Dir,Eve}$(X*,o')\loimplies\linebreak
	\ablock \loneg MayAffect$^{Eve}$(o,o') \linebreak
\hrule
\end{logic}
\textsc{ncc1} says that in order for an object o to modify the state of o', there must exist an object X* that has a direct path to o', and that X* \textit{can} traverse such a path. This is derived trivially from our \textsc{pfa} assumption. Consequently, in our contraposition result, we can deny \textit{all} objects in our system capability of o' to enforce the protection of o' from o. \textsc{nec1} does not yield a very useful result, as this is just another way of implementing protection of o' from o through denying all paths to o' in the system reference graph. To see why denying all objects the capability of o' is equivalent to denying all paths to o', see the contraposition result from \textsc{gpe}.\\

In \textsc{ncc1}, if X* refers to the same object as o, then we have a straightforward configuration where object o has the capability of o' and can therefore affect o'. However, very crucially, o having the capability of o' is \textit{not} a sufficient condition---denying o the capability of o' does \textit{not} deny o the ability to affect o', since X* can refer to an object that is \textit{not} o. \textsc{ncc2} below is an expansion of \textsc{ncc1} to illustrate this crucial point.
\begin{logic}
\hrule\null
\textsc{\normalsize *Necessary Capability Condition 2 (NCC2)}\\
M,\losigma\ \loturns\ MayAffect$^{Eve}$(o,o') \loimplies\linebreak
	\ablock $[$MayAccess$^{Dir,Eve}$(o,o') \loor\linebreak
	\ablock \loexists X*\loin{Obj}, X*\loneq o. MayAccess$^{Dir,Eve}$(X*,o')$]$
\linebreak\\
\textit{By contraposition,}\linebreak
M,\losigma\ \loturns\ $[$\loneg MayAccess$^{Dir,Eve}$(o,o') \loand\linebreak
	\ablock \loforall X*\loin{Obj}, X*\loneq o. \loneg MayAccess$^{Dir,Eve}$(X*,o')$]$ \linebreak
	\ablock \loimplies\loneg MayAffect$^{Eve}$(o,o')\linebreak
\hrule
\end{logic}
With this clarification, we then reason about the relationship between protection of state (MayAffect) and paths (MayAccess$^{Ind,*}$). The question we ask is what is the relation between state protection in eventual outcomes, and present path configurations? We build this relationship from the basics by progressively finding stronger conditions of MayAffect. We begin with the first condition, which says that for an object to affect another, an \textit{eventual} path has to exist. This can be derived from the definitions of our predicates.
\begin{logic}
\hrule\null
\textsc{\normalsize *Necessary Path Condition 1 (NPC1)}\\
M,\losigma\ \loturns\ MayAffect$^{Eve}$(o,o') \loimplies\linebreak
	\ablock MayAccess$^{Ind,Eve}$(o,o')
\linebreak \\
\textit{By contraposition,}\linebreak
M,\losigma\ \loturns\ \loneg MayAccess$^{Ind,Eve}$(o,o') \loimplies\linebreak
	\ablock \loneg MayAffect$^{Eve}$(o,o')
\linebreak
\hrule
\end{logic}
Here, we immediately see a first defensive outcome of the OCap model. Having no eventual paths from object o to o' guarantees that the state of object o' cannot be modified by object o.\\

So far our results serve as a good base to enforce \loneg MayAffect$^{Eve}$(o,o') but we require \textit{stronger} necessary conditions for MayAffect$^{Eve}$(o,o'), because we need to understand the present path configurations that can deny o from modifying o'. Luckily, we have already built the necessary ingredients in our formalizations of OCap rules in \ref{ocaprules}, where have painstakingly derive the relationship between present path configurations and eventual paths. Since \textsc{npc1} tells us that the eventual paths is a necessary condition for object state modification, and \textsc{epc1} tells us the the relationship between eventual paths and present path configurations, we combine the two to present: 

\begin{logic}
\hrule\null
\textsc{\normalsize *Necessary Path Condition 2 (NPC2)}\\
M,\losigma\ \loturns\ MayAffect$^{Eve}$(o,o')\linebreak
\ablock \loimplies\linebreak
\ablock \loexists X*\loin Obj.$[($MayAccess$^{Ind,Now}$(o,X*) \loor \linebreak
\ablock \ablock \ablock \quad MayAccess$^{Dir,Now}$(X*,o)$)$\linebreak
\ablock \ablock \ablock \ablock \loand \linebreak
\ablock \ablock \ablock \quad MayAccess$^{Ind,Eve}$(X*,o')$]$
\linebreak \\
\textit{By contraposition,}\linebreak
M,\losigma\ \loturns\ 
\loforall X*\loin Obj. $[$\loneg MayAccess$^{Ind,Now}$(o,X*) \loand \linebreak
\ablock \ablock \ablock \ablock \loneg MayAccess$^{Dir,Now}$(X*,o)$]$\linebreak
\ablock \ablock \ablock \ablock \loor \linebreak
\ablock \ablock \ablock \ablock \loneg MayAccess$^{Ind,Eve}$(X*,o')$]$\linebreak
\ablock \loimplies \linebreak
	\ablock\loneg MayAffect$^{Eve}(o,o')$\linebreak
\hrule
\end{logic}
, where \textsc{npc2} is similar to \textsc{epc2}, where we can always use \textsc{gpec} to expand indirect paths into direct capabilities till we reach the terminating origin o and recursively use \textsc{epc2} to expand MayAccess$^{Ind,Eve}$(X*,o') till we reach the terminating MayAccess$^{Ind,Eve}$(o',o'). The final result through such as expansion is similar to \textsc{epc3***}. We use \textsc{epc3***} to make explicit the relationship between a configuration of direct capabilities between objects at \losigma, and the ability to modify state at some arising \losigma', which we call \textsc{ncc3***}:
\begin{logic}
\hrule\null
\textsc{\normalsize *Necessary Capability Condition 3*** (NCC3***)}\\
M,\losigma\ \loturns\ MayAffect$^{Ind,Eve}$(o,o')\linebreak
\ablock \loimplies\linebreak
\ablock \loexists X*, x$^{1...n}$\loin Obj.$\{[$MayAccess$^{Ind,Now}$(o,o)\linebreak
\ablock \ablock \ablock \ablock \ablock \loand\linebreak
\ablock \ablock \ablock \ablock \ablock MayAccess$^{Dir,Now}$(o,x$^1$)\linebreak
\ablock \ablock \ablock \ablock \ablock $\vdots$\linebreak
\ablock \ablock \ablock \ablock \ablock MayAccess$^{Dir,Now}$(x$^{n-1}$,x$^n$)\linebreak
\ablock \ablock \ablock \ablock \ablock \loand\linebreak
\ablock \ablock \ablock \ablock \ablock MayAccess$^{Dir,Now}$(x$^n$,X*)$]$\linebreak
\ablock \ablock \ablock \ablock \quad\: \loor \linebreak
\ablock \ablock \ablock \ablock \quad\: MayAccess$^{Dir,Now}$(X*,o)$\}$\linebreak
\ablock \ablock \ablock \ablock \loand \linebreak
\ablock \ablock \ablock \quad MayAccess$^{Ind,Eve}$(X*,o')\linebreak\\

\ablock \textit{where if o exists in \losigma,} \linebreak
\ablock \loturns\ MayAccess$^{Ind,Now}$(o,o) is true\linebreak\linebreak\
\ablock \textit{where if o' exists in some \losigma',}\linebreak
\ablock \loturns\ MayAccess$^{Ind,Eve}$(o',o') is true\linebreak
\hrule
\end{logic}

\textsc{ncc3***} gives us the present \textit{capability} configurations that will allow an eventual path from o to o', which is a necessary condition for o to modify o', and tells us that we can enforce protection of o' from o by denying all eventual paths from o to o'. But if those objects must \textit{always} and at all states be path-isolated, how do we allow them to cooperate? 

\subsection{What about Cooperation?}


It is good to know we can enforce protection through some present path configurations that can guarantee eventual path-isolation, but in practice this is still not entirely useful. The quintessential question in OCap systems is whether we can enforce protection such as controlling whether o may affect o', on \textit{some condition}. In our framework, this just means that cooperation between objects require paths to exist based on some condition. This is made possible, because of Rule 3 that says objects may have private encapsulation of state and behaviour, which enables an object to deny paths leading in and leading out of it. Can our framework incorporate this?\\

How do we then express these internal object security policies in our logical framework?

It is worth revisiting our general specifications for the MayAccess$^{Dir,Eve}$ predicate, which is extremely \textit{weak}, because they have no special conditions:
\begin{logic}[MayAccess$^{Dir,Eve}$]
M,\losigma\ \loturns\ MayAccess$^{Dir,Eve}$(x,e) \loiff \linebreak
\ablock \loexists \losigma' \loin Arising(M,\losigma).\linebreak
\ablock \loexists f. \loexec{x.f}{\losigma'} = \loexec{e}{\losigma'}
\loor \linebreak
\ablock (\losigma'(this) = \loexec{x}{\losigma'} \loand\ \loexists y. \losigma'(y) = \loexec{e}{\losigma'})\linebreak
\ablock \loand\ $\{\}$\texttt{ // No conditions}
\end{logic}

The reason why we have not used any special conditions is because this also allows us to generalize any kind of object which we do not know how it behaves. The most dangerous kind of objects are those that exposes all their behaviours to be public, and can expose all capabilities that is possesses through those behaviours. In that end, our general specifications are meant to assume a worst-case scenario, and hence it is no surprise that we insist on path-isolation to guarantee protection.\\


But, what if we have code knowledge of some set of objects in our system so we know how they behave?\\

Let us assume we know a simple object o' that has \textit{only} private behaviours, and belongs to class called IsoObj that we have code knowledge of. In such a scenario, since all fields in our system are also assumed to be private, then we know:
\begin{logic}[MayAccess$^{Dir,Eve}$(X*, o']
M,\losigma\ \loturns\ \loforall\ X*\loin Obj, o'\loin IsoObj. MayAccess$^{Dir,Eve}$(X*,o')\linebreak
\ablock \loiff \linebreak
\ablock \loexists \losigma' \loin Arising(M,\losigma).\linebreak
\ablock \loexists f. \loexec{X*.f}{\losigma'} = \loexec{o'}{\losigma'}
\loor \linebreak
\ablock (\losigma'(this) = \loexec{X*}{\losigma'} \loand\ \loexists y. \losigma'(y) = \loexec{o'}{\losigma'})\linebreak
\ablock \loand\ $\bot$. $\{$\texttt{//Condition: Always false}$\}$
\end{logic}
Even though in theory any object may possess the capability of o', as long as we know there is no way for anybody to \textit{exercise} the capability of o' in under any condition (because o' has restricted all incoming messaages as it has no behaviours), in terms of security concerns, it \textit{is equivalent} to o' being an isolated object with all objects not having any direct paths to o' in all eventual states.
That is, o' might very well be an isolated object \textit{despite} every object having the capability of o':
\begin{itemize}
\item \begin{logic} M,\losigma\ \loturns\ \loforall X*\loin Obj, o'\loin IsoObj. MayAccess$^{Dir,Eve}$(X*,o')\linebreak 
\ablock \loiff $\bot$ \end{logic}
\end{itemize}
Furthermore, since our results in \textsc{npc1} tells us that path is a necessary condition to modify an object, and \textsc{gpe} says denying \textit{all} capabilities in the system to o' is equivalent to denying all paths to o' in the system, then we know:
\begin{logic} M,\losigma\ \loturns\ \loforall X*\loin Obj. \loneg MayAccess$^{Dir,Eve}$(X*,o')\linebreak
\ablock \ablock \loimplies \linebreak
\ablock \ablock \loneg MayAccess$^{Ind,Eve}$(X*,o')\linebreak
\ablock \ablock \loimplies \linebreak
\ablock \ablock \loneg MayAffect$^{Eve}$(X*,o')\linebreak
\end{logic}

Since \textit{all} objects do not have the path of o', then we know o' is protected. To put it in another way, we can now determine paths into o',  based on some condition \textit{written} in o'. This means that objects can specify security policies on the incoming messages it receives and enforce protection on \textit{itself} \textit{internally}. But, can objects specify security policies \textit{externally} on the outgoing messages to the capabilities that is possesses? Of course this is possible. Let us see how we further develop this in our framework with another example.\\


We have some starting configuration in a system where there is some object Y* that belongs to a class called AttenObj which we have code knowledge of, and that Y* has the capability of o' that belongs to a class called ProtectObj. Note that we do not need code knowledge of ProtectObj to enforce a policy of how Y* might want to interact with o'. Since Y* has the capabilitiy of o', we say Y* has the power to enforce the conditions on when it will exercise it. To put it in another way, we can now allow an outgoing path to exist from Y* to o', based on some condition \textit{written in Y*}:

\begin{itemize}
\item If Y* has no behaviour that will make use of and call the capability of o' in any outgoing messages:
\begin{logic}
M,\losigma\ \loturns\ \loforall\ Y*\loin AttenObj, o'\loin ProtectObj. MayAccess$^{Dir,Eve}$(Y*,o')\linebreak
\ablock \loiff \linebreak
\ablock \loexists \losigma' \loin Arising(M,\losigma).\linebreak
\ablock \loexists f. \loexec{Y*.f}{\losigma'} = \loexec{o'}{\losigma'}
\loor \linebreak
\ablock (\losigma'(this) = \loexec{Y*}{\losigma'} \loand\ \loexists y. \losigma'(y) = \loexec{o'}{\losigma'})\linebreak
\ablock \loand\ $\bot$. \texttt{//Condition: Always false}
\end{logic}
\item Y* has only one behaviour that will use the capability of o' if it holds a boolean field \texttt{access} that is evaluated to true at the time of the access call:
\begin{logic}
M,\losigma\ \loturns\ \loforall\ Y*\loin AttenObj, o'\loin ProtectObj. MayAccess$^{Dir,Eve}$(Y*,o')\linebreak
\ablock \loiff \linebreak
\ablock \loexists \losigma' \loin Arising(M,\losigma').\linebreak
\ablock \loexists f. \loexec{Y*.f}{\losigma'} = \loexec{o'}{\losigma'}
\loor \linebreak
\ablock (\losigma(this) = \loexec{Y*}{\losigma'} \loand\ \loexists y. \losigma'(y) = \loexec{o'}{\losigma'})\linebreak
\ablock \loand\ \loexec{x.\texttt{allow}}{\losigma'} = \loexec{\texttt{true}}{\losigma'}.
\ablock \texttt{//Condition: only when boolean\\ \quad variable allow is true}
\end{logic}
\end{itemize}
Note the difference in this example where we \textit{cannot} say that Y* may not modify o', because direct capability from Y* to o' is \textit{not} a sufficient condition, and Y* does not represent all objects in our system (Y*\loin AttenObj, AttenObj \loin Obj). \textit{Y* may still find some \textit{other} path to o' to modify o'}.
\begin{logic} M,\losigma\ \loturns\ \loforall Y*\loin AttenObj. \loneg MayAccess$^{Dir,Eve}$(Y*,o')\linebreak
\ablock \ablock \lonimplies \linebreak
\ablock \ablock \loneg MayAccess$^{Ind,Eve}$(Y*,o')\linebreak
\ablock \ablock \lonimplies \linebreak
\ablock \ablock \loneg MayAffect$^{Eve}$(Y*,o')\linebreak
\end{logic}

We can now make use of our result of Domination, to say that if in the system of configuration all paths to o' must go through a set of X*, or conversely, Y* are the only objects that hold the direct capability of o', then we can reason:

\begin{logic} M,\losigma\ \loturns\ \loforall X*\loin Obj, Y*\loin AttenObj, AttenObj \loin Obj. \linebreak
\ablock \ablock Dom(Y*,o') \loand\ MayAccess$^{Ind,Eve}$(X*,o')\linebreak
\ablock \ablock \loimplies \linebreak
\ablock \ablock MayAccess$^{Dir,Eve}$(Y*,o')\linebreak\\

\textit{By contraposition,}\linebreak
\ablock \ablock \loneg MayAccess$^{Dir,Eve}$(Y*,o')\linebreak
\ablock \ablock \loimplies \linebreak
\ablock \ablock \loneg Dom(Y*,o') \loor\ \loneg MayAccess$^{Ind,Eve}$(X*,o')\linebreak\\

\textit{Imposing dominance in antecedent,}\linebreak
\ablock \ablock \loneg MayAccess$^{Dir,Eve}$(Y*,o') \loand\ Dom(Y*,o')\linebreak
\ablock \ablock \loimplies \linebreak
\ablock \ablock \loneg MayAccess$^{Ind,Eve}$(X*,o')\linebreak
\ablock \ablock \loimplies \linebreak
\ablock \ablock \loneg MayAccess$^{Ind,Eve}$(Y*,o') \textit{, since Y*\loin X*}\linebreak
\ablock \ablock \loand\ MayAffect$^{Eve}$(X*,o')\textit{, from \textsc{npc1}}\linebreak
\ablock \ablock \loimplies \linebreak
\ablock \ablock \loneg MayAffect$^{Eve}$(Y*,o')\linebreak
\end{logic}
This means that if we deny Y* an eventual direct path to o' \textit{and} Y* dominates o', then equivalently, we deny all objects an eventual path to o' and deny all objects, including Y*, the ability to modify o'.\\

We can also show dominance by extending our necessary capability condition \textsc{ncc3***}. If we can guarantee that Y* is the only object in the system that holds the direct capability of o', and we deny Y* a direct path to o', then we know the last object in the eventual path to o' is Y* and we can simply expand the last term in \textsc{ncc3***} to state explicitly that Y* has to be the object that connects directly eventually to o':
\begin{minipage}{\linewidth}
\begin{logic}
\hrule\null
\textsc{\normalsize *Necessary Dominating Condition*** (NDC***)}\\
If Y* dominates o' then:\\
M,\losigma\ \loturns\ MayAffect$^{Ind,Eve}$(o,o') \loand\ Dom(Y*,o')\linebreak
\ablock \loimplies\linebreak
\ablock \loexists X*, x$^{1...n}$\loin Obj.$\{[$MayAccess$^{Ind,Now}$(o,o)\linebreak
\ablock \ablock \ablock \ablock \ablock \loand\linebreak
\ablock \ablock \ablock \ablock \ablock MayAccess$^{Dir,Now}$(o,x$^1$)\linebreak
\ablock \ablock \ablock \ablock \ablock $\vdots$\linebreak
\ablock \ablock \ablock \ablock \ablock MayAccess$^{Dir,Now}$(x$^{n-1}$,x$^n$)\linebreak
\ablock \ablock \ablock \ablock \ablock \loand\linebreak
\ablock \ablock \ablock \ablock \ablock MayAccess$^{Dir,Now}$(x$^n$,X*)$]$\linebreak
\ablock \ablock \ablock \ablock \quad\: \loor \linebreak
\ablock \ablock \ablock \ablock \quad\: MayAccess$^{Dir,Now}$(X*,o)$\}$\linebreak
\ablock \ablock \ablock \ablock \loand \linebreak
\ablock \ablock \loexists Y*\loin{AttenObj}.$[$MayAccess$^{Ind,Eve}$(X*, Y*) \loand\linebreak
\ablock \ablock \ablock \ablock \ablock \quad MayAccess$^{Dir,Eve}$(Y*,o')$]$

\ablock \textit{where if o exists in \losigma,} \linebreak
\ablock \loturns\ MayAccess$^{Ind,Now}$(o,o) is true\linebreak\linebreak\
\ablock \textit{where if o' exists in some \losigma',}\linebreak
\ablock \loturns\ MayAccess$^{Dir,Eve}$(o',o') is true\linebreak
\hrule
\end{logic}
\end{minipage}\linebreak\\
Our analysis shows the importance of attenuating objects---objects that perform their roles as \textit{defensive} objects along the eventual paths to our protected objects. If the protected object can guarantee through the system of configuration that those attenuating objects are the \textit{only} objects in the entire system that holds its capability in \textit{all} eventual states, then the protected object can dictate the conditions and degree of control on how it can be used by untrusted objects in all eventual states through those attenuating objects. This ability of the protected object to dictate control across time and conditions enables cooperation, where conditions on how the protected object will cooperate is written in those attenuating objects.\\

The logics we have developed show that security of an object can be enforced in an OCap model by:
\begin{itemize}
\item being careful about our present path configurations so that we can ensure eventual path-isolation between the object and untrusted object
\item specifying security policies {within} objects that dictate how incoming messages and outgoing messages are handled, so that path-isolation or existence rests on some condition
\end{itemize}
Therein lies also the difference between OCap and non-OCap models, because non-OCap models that allow forging of capabilities or a global ambient authoriy \textit{cannot} enforce security through path isolation, which is a distinctive feature of OCap models.\\

The similarity is that both models allow us to specify policies \textit{within} objects as to whether an object's behaviour can be called (note that non-OCap systems can also do so 'externally' through a global ambient authority). 'Internal' object protection can be done through using defensive programming techniques like encapsulation and checking of conditions for behaviours to succeed. In a way these forms of protection can be considered a form of 'stack-based' access control from the called object's perspective, because they only happen \textit{after} the calling object has already called the object.\\

In the OCap pattern examples we will go through in the next section, protection of an object is typically accomplished through some attenuating object that the protected object knows will never leak its capability directly such that the attenuating objects dominate the trusted object (the trusted object can ensure this if it creates those attenuating objects), and that protection is enforced through some security policies \textit{within} those attenuating objects.\\



\subsection{Pattern 1: The JavaScript DOM Tree}
We use a JavaScript DOM Tree OCap pattern largely inspired by the example in Devriese et al.\cite{devriese2016} where they use a Kripke worlds framework to reason about the pattern. We define the following variables throughout our pattern:
\begin{itemize}
\item o,o' \loin Object
\item Node,ReNode \losubseteq Object
\item n,n' \loin Node
\item rn,rn' \loin ReNode
\end{itemize}

\begin{logic}[NodeVul]
\hrule\null
\textsc{\normalsize *Node Vulnerability}\\
\loforall o, n. MayAccess$^{Dir,Now}$(o,n)\linebreak \ablock\ablock \loimplies \linebreak
\ablock \ablock MayAffect$^{Now}$(o,n) \loand \linebreak
\ablock \ablock \loforall n'. MayAccess$^{Dir,Now}$(o,n')
\end{logic}
The vulnerability of a node lies in the fact that it contains a public method \texttt{setProperty(key,value)} that will modify an internal mapping data structure. A node also has a public field \texttt{parent} that will return the capability of its parent node. Consequently, this allows an object which has the capability of any one node in the tree to navigate up to the root node (Document), and consequently navigate to all other nodes in the tree.\\

\begin{minipage}{\linewidth}
\begin{logic}
\hrule\null
\textsc{\normalsize *Necessary Node Condition***}\\
If Y* dominates o' then:\\
M,\losigma\ \loturns\ \loforall o\loin Obj, rn\loin ReNode, n\loin Node\linebreak
ReNode\loin Obj, Node\loin Obj.\linebreak
\ablock MayAffect$^{Eve}$(o,n) \loand\ Dom(RN*,n)\linebreak
\ablock \loimplies\linebreak
\ablock \loexists X*\loin Obj.$\{[$MayAccess$^{Ind,Eve}$(o,X*)\linebreak
\ablock \ablock \ablock \ablock \quad\: \loor \linebreak
\ablock \ablock \ablock \ablock \quad\: MayAccess$^{Dir,Now}$(X*,o)$\}$\linebreak
\ablock \ablock \ablock \ablock \loand \linebreak
\ablock \ablock \loexists rn\loin{RN*}.$[$MayAccess$^{Ind,Eve}$(X*, rn) \loand\linebreak
\ablock \ablock \ablock \ablock \ablock \quad MayAccess$^{Dir,Eve}$(rn,o')$]$

\ablock \textit{where if o exists in \losigma,} \linebreak
\ablock \loturns\ MayAccess$^{Ind,Now}$(o,o) is true\linebreak\linebreak\
\ablock \textit{where if o' exists in some \losigma',}\linebreak
\ablock \loturns\ MayAccess$^{Dir,Eve}$(o',o') is true\linebreak
\hrule

\hrule
\end{logic}
\end{minipage}\linebreak\\
\begin{logic} 
\hrule\null
\textsc{\normalsize *ReNode to Node Condition*}\\
M,\losigma\ \loturns\ \loforall rn\loin ReNode. MayAccess$^{Dir,Eve}$(rn,n)\linebreak
\ablock \loimplies \linebreak
\ablock \loexists \losigma' \loin Arising(M,\losigma).\linebreak
\ablock \ablock \loexec{rn.\texttt{node}}{\losigma'} = \loexec{e}{\losigma'} \loand\ \{\texttt{e is n}\}\linebreak
\hrule
\end{logic}

\begin{logic} 
\hrule\null
\textsc{\normalsize *ReNode Parenthood Condition*}\\
M,\losigma\ \loturns\ \loforall rn,rn.parent \loin ReNode. MayAccess$^{Dir,Eve}$(rn,rn.parent)\linebreak
\ablock \loimplies \linebreak
\ablock \loexists \losigma' \loin Arising(M,\losigma).\linebreak
\ablock \loand\ \loexec{rn.\texttt{depth}}{\losigma'} = \loexec{e}{\losigma'} \loand\ e > 0\linebreak
\hrule
\end{logic}

\begin{logic} 
\hrule\null
\textsc{\normalsize *ReNode Definition*}\\
M,\losigma\ \loturns\ \loforall rn,rn' \loin ReNode, n,n' \loin Node.\linebreak
\ablock \loforall \losigma' \loin Arising(M,\losigma).\linebreak
\ablock \loexec{rn.\texttt{depth}}{\losigma'} = \loexec{d}{\losigma'} \loand \linebreak
\ablock \loexec{rn.\texttt{node}}{\losigma'} = \loexec{n}{\losigma'} \loand \linebreak
\ablock \loexec{rn.\texttt{parent}}{\losigma'} = \loexec{rn'}{\losigma'} \loand\linebreak
\ablock \loexec{rn'.\texttt{depth}}{\losigma'} = \loexec{d'}{\losigma'} \loand\ d' = d - 1\linebreak
\ablock \loexec{rn'.\texttt{node}}{\losigma'} = \loexec{n'}{\losigma'} \loand\ n' = \loexec{n.\texttt{parent}}{\losigma'}\linebreak
\hrule
\end{logic}
\begin{logic} 
\hrule\null
\textsc{\normalsize *Node Definition*}\\
M,\losigma\ \loturns\ \loforall n,n.parent \loin Node.\linebreak
\ablock \loforall \losigma' \loin Arising(M,\losigma).\linebreak
\ablock \loexec{n.\texttt{parent}}{\losigma'} = \loexec{p}{\losigma'} \loand \linebreak
\hrule
\end{logic}

%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------
\small
\bibliographystyle{plain}
\bibliography{ref}

%----------------------------------------------------------------------------------------

\end{document}

